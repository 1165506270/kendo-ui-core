#!/usr/bin/env node

var xml = require("libxmljs"),
    fs = require("fs"),
    path = require("path");

var rawApi = fs.readFileSync("wrappers/mvc/src/Kendo.Mvc/bin/Release/Kendo.Mvc.xml", "utf8");
var xmlDoc = xml.parseXmlString(rawApi);
var members = xmlDoc.find("//member")

function parseNamespace(namespace) {
    var namespaceRegExp = new RegExp("(\\w):" + namespace.replace(/\./g, "\\.") + "\\.([^\\.]+)\\.");
    var types = {};

    members.forEach(function(member) {
        var name = member.attr("name").value();
        var type;
        var kind;
        var fullName;

        if (namespaceRegExp.test(name)) {
            kind = RegExp.$1;
            fullName = namespace + "." + RegExp.$2;
            type = types[fullName];

            if (!type) {
                types [fullName] = type = {};
                type.name = fullName;
                type.methods = [];
                type.properties = [];
            }

            if (kind == "M") {
                var method = parseMethod(member);

                if (!isEmpty(method)) {
                    method.name = memberName(fullName, name)
                    type.methods.push(method);
                }
            }
        }
    });

    return types;
}

function typeToMarkdown(type) {
    var markdown = "";

    markdown += "---";
    markdown += "\ntitle:" + type.name;
    markdown += "\nslug:aspnetmvc-" + type.name.toLowerCase();
    markdown += "\npublish:true";
    markdown += "\n---";

    markdown += "\n\n# " + type.name;

    if (type.methods.length) {
        markdown += "\n\n## Methods";

        type.methods.forEach(function(method){
            markdown += emitMethod(method);
        });
    }

    return markdown;
}

function emitMethod(method) {
    var markdown = "";

    markdown += "\n\n### " + method.name;

    if (method.summary) {
        markdown += "\n" + method.summary;
    }

    if (method.params) {
        var paramTypes = /\(([^\)]*)\)$/.exec(method.name)[1].split(",");

        markdown += "\n\n#### Parameters";

        method.params.forEach(function(param, index) {
            markdown += emitParam(param, paramTypes[index]);
        })
    }

    return markdown;
}

function emitParam(param, type) {
    var markdown = "";

    markdown += "\n\n##### " + param.name + " `" + type + "`";

    if (param.summary) {
        markdown += "\n" + param.summary;
    }

    return markdown;
}

function memberName(typeName, name) {
    return name.replace(/\w:/, "").substring(typeName.length + 1);
}

function parseMethod(element) {
    var result = {};
    var summary = element.get("summary");

    if (summary) {
        result.summary = summary.text().trim();
    }

    var params = element.find("param");

    if (params.length) {
        result.params = params.map(function(param){
            return {
               name: param.attr("name").value(),
               summary: param.text()
            }
        });
    }

    return result;
}

function isEmpty(object) {
    for (var member in object) {
        return false;
    }

    return true;
}

function makePath(/**Array*/ path) {
     path = path.split(/[\\\/]/);
    var make = "";

    for (var i = 0, l = path.length; i < l; i++) {
        make += path[i] + "/";
        if (!exists(make)) {
            makeDir(make);
        }
    }
}

function saveFile(/**string*/ outDir, /**string*/ fileName, /**string*/ content) {
    fs.writeFileSync(outDir + "/" + fileName, content, "utf8");
}

function exists(/**string*/ path) {
    try {
        fs.statSync(path);
        return true;
    } catch(e) {
        return false;
    }
}

function makeDir(/**string*/ path) {
    fs.mkdirSync(path, 0777);
}

var types = parseNamespace("Kendo.Mvc.UI.Fluent");
var path = "docs/api/wrappers/asp-net-mvc/reference/";

makePath(path);

for (var type in types) {
    saveFile(path, type + ".md", typeToMarkdown(types[type]));
}

// vim: ft=javascript
