<!DOCTYPE html>
<html>
    <head>
        <title>Chart Playground</title>
        <script src="../src/jquery.js"></script>
        <script src="../src/kendo.core.js"></script>
        <script src="../src/kendo.chart.js"></script>
    </head>
    <body>
        <script type="text/javascript">

            function Box(x1, y1, x2, y2) {
                this.x1 = x1;
                this.x2 = x2;
                this.y1 = y1;
                this.y2 = y2;
            }

            Box.prototype = {
                width: function() {
                    return this.x2 - this.x1;
                },

                height: function() {
                    return this.y2 - this.y1;
                }
            }

            function boxDiff( r, s ) {
                var a = Math.min( r.x1, s.x1 );
                var b = Math.max( r.x1, s.x1 );
                var c = Math.min( r.x2, s.x2 );
                var d = Math.max( r.x2, s.x2 );

                var e = Math.min( r.y1, s.y1 );
                var f = Math.max( r.y1, s.y1 );
                var g = Math.min( r.y2, s.y2 );
                var h = Math.max( r.y2, s.y2 );

                // X = intersection, 0-7 = possible difference areas
                // h +-+-+-+
                // . |5|6|7|
                // g +-+-+-+
                // . |3|X|4|
                // f +-+-+-+
                // . |0|1|2|
                // e +-+-+-+
                // . a b c d

                var result = [];

                // we'll always have rectangles 1, 3, 4 and 6
                result[ 0 ] = new Box( b, e, c, f );
                result[ 1 ] = new Box( a, f, b, g );
                result[ 2 ] = new Box( c, f, d, g );
                result[ 3 ] = new Box( b, g, c, h );

                // decide which corners
                if( r.x1 == a && r.y1 == e || s.x1 == a && s.y1 == e )
                { // corners 0 and 7
                    result[ 4 ] = new Box( a, e, b, f );
                    result[ 5 ] = new Box( c, g, d, h );
                }
                else
                { // corners 2 and 5
                    result[ 4 ] = new Box( c, e, d, f );
                    result[ 5 ] = new Box( a, g, b, h );
                }

                return $.grep(result, function(box) {
                    return box.height() > 0 && box.width() > 0
                })[0];
            }

            var svgNS = "http://www.w3.org/2000/svg";

            var SVGPrimitive = function(element, surface) {
                this.surface = surface;
                this.element = $(element);
            }

            $.extend(SVGPrimitive.prototype, {
                text: function(value) {
                    this.element.text(value);
                    return this;
                },

                css: function() {
                    var that = this,
                        element = that.element;

                    element.css.apply(element, arguments);
                    return that;
                },

                attr: function(key, value) {
                    var that = this,
                        element = that.element;

                    if (typeof key == "string") {
                        if (typeof value != "undefined") {
                            element[0].setAttribute(key, value);
                        } else {
                            return element[0].getAttribute(key);
                        }
                    } else {
                        var map = key;
                        for (var attrKey in map) {
                            element[0].setAttribute(attrKey, map[attrKey]);
                        }
                    }

                    return that;
                },

                height: function(value) {
                    if (value) {
                        this.attr({ height: value });
                    } else {
                        return this.getBBox().height;
                    }
                },

                width: function(value) {
                    if (value) {
                        this.attr({ width: value });
                    } else {
                        return this.getBBox().width;
                    }
                },

                translate: function(dx, dy) {
                    this.attr({ transform: "translate(" + dx + ", " + dy + ")" });
                },

                getBBox: function() {
                    return this.element[0].getBBox();
                },

                getComputedStyle: function() {
                    return window.getComputedStyle(this.element[0]);
                },

                hAlign: function (hAlign, box) {
                    var x = this.attr("x"),
                        offsetX = 0,
                        box = box || this.surface.box;

                    if (hAlign == "center") {
                        offsetX = (box.width() - this.width()) / 2;
                    }

                    this.attr("x", x + offsetX);

                    return this;
                },

                empty: function() {
                    this.element.empty();
                }
            });

            var SVGSurface = function(container) {
                var surface = this,
                    options = surface.options = $.extend(SVGSurface.prototype.defaults, options),
                    container = $(container),
                    element = surface.element = this._createElement("svg", container);

                container.append(element.element);

                surface.box = new Box(0, 0, container.width(), container.height());
            }

            $.extend(SVGSurface.prototype, {
                defaults: {
                    width: "100%",
                    height: "100%"
                },

                group: function(parentElement) {
                    return this._createElement("g", parentElement);
                },

                desc: function(text, parentElement) {
                    var desc = this._createElement("desc", parentElement);
                    desc.text(text);

                    return desc;
                },

                text: function(text, parentElement) {
                    var textElement = this._createElement("text", parentElement);
                    textElement.text(text);

                    return textElement;
                },

                rect: function(options, parentElement) {
                    var rect = this._createElement("rect", parentElement);
                    rect.attr(options);

                    return rect;
                },

                line: function(options, parentElement) {
                    var line = this._createElement("line", parentElement);
                    line.attr(options);

                    return line;
                },

                _createElement: function(tagName, parentElement) {
                    var that = this,
                        parentNode = parentElement ? parentElement.element || parentElement : that.element.element,
                        element = document.createElementNS(svgNS, tagName);

                    parentNode.append(element);
                    return new SVGPrimitive(element, this);
                }
            });

            function ChartTitle(surface, box, options) {
                var title = this,
                    element = title.element = surface.group(),
                    desc = surface.desc("Chart Title", element);

                title.options = options;

                var text = surface
                    .text(options.text, element)
                    .css(options.style)
                    .attr({ x: box.x1, "y": box.y1 })
                    .hAlign("center", box);

                vAlignText(text, "top");

                title.box = new Box(box.x1, box.y1, box.x2, text.height());
            }

            $.extend(ChartTitle.prototype, {
            });

            // Aligns text vertically
            // Requires text primitive with set Y position
            function vAlignText(textPrimitive, vAlign) {
                    var bbox = textPrimitive.getBBox(),
                        y = parseInt(textPrimitive.attr("y")),
                        offsetY = 0,
                        textHeight = (y - bbox.y),
                        fontSize = parseInt(textPrimitive.getComputedStyle().fontSize);

                    if (vAlign == "center") {
                        offsetY = (textHeight / 2) - (bbox.height - fontSize);
                    } else if (vAlign == "top") {
                        offsetY = bbox.height;
                    } else if (vAlign == "bottom") {
                        var heightAboveBaseline = y - bbox.y;
                        offsetY -= bbox.height - heightAboveBaseline;
                    }

                    textPrimitive.attr("y", y + offsetY);
            };

            // Numeric Axis
            var DEFAULT_PRECISION = 6,
                ZERO_THRESHOLD = 0.2;

            function NumericAxis(surface, box, options) {
                var axis = this,
                    element = axis.element = surface.group();

                var majorUnit = axis.getMajorUnit(options.min, options.max),
                    axisMax = axis.getAxisMax(options.min, options.max),
                    axisMin = axis.getAxisMin(options.min, options.max),
                    majorTicks = Math.round((axisMax - axisMin) / majorUnit) + 1;

                var totalHeight = box.height();
                var step = totalHeight / (majorTicks - 1);
                var currentY = box.y1;
                var currentValue = axisMax;
                var labels = [];
                for (var i = 0; i < majorTicks; i++) {
                    var text = surface.text(currentValue, element);

                    text.css(options.labels.style)
                        .attr("x", 0)
                        .attr("y", currentY);

                    labels.push(text);

                    vAlignText(text, "center");

                    currentY += step;
                    currentValue -= majorUnit;
                }

                var offsetX = axis.element.width();
                for (var i = 0; i < labels.length; i++) {
                    labels[i].attr("x", offsetX).attr("text-anchor", "end");
                }

                var lineX = axis.element.getBBox().width,
                    lineStyle = $.extend({}, options, { x1: lineX, y1: box.y1, x2: lineX, y2: box.y2 });

                surface.line(lineStyle, axis.element);

                this.box = new Box(box.x1, box.y1, element.width(), box.y2);
                this.min = axisMin;
                this.max = axisMax;
            }

            NumericAxis.prototype = {
                getMajorUnit: function (min, max) {
                    var diff = max - min;
                    if (diff == 0) {
                        if (max == 0) {
                            return 0.1;
                        }

                        diff = Math.abs(max);
                    }

                    var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10))),
                        relativeValue = round((diff / scale), DEFAULT_PRECISION),
                        scaleMultiplier = 1;

                    if (relativeValue < 1.904762) {
                        scaleMultiplier = 0.2;
                    } else if (relativeValue < 4.761904) {
                        scaleMultiplier = 0.5;
                    } else if (relativeValue < 9.523809) {
                        scaleMultiplier = 1;
                    } else {
                        scaleMultiplier = 2;
                    }

                    return round(scale * scaleMultiplier, DEFAULT_PRECISION);
                },

                getAxisMax: function(min, max) {
                    if (min == 0 && max == 0) {
                        return 1;
                    }

                    var axisMax;
                    if (min <= 0 && max <= 0) {
                        max = min == max ? 0 : max;

                        var diff = Math.abs((max - min) / max);
                        if(diff > ZERO_THRESHOLD) {
                            return 0;
                        }

                        axisMax = max - ((min - max) / 2);
                    } else {
                        min = min == max ? 0 : min;
                        axisMax = max + 0.05 * (max - min);
                    }

                    var mu = this.getMajorUnit(min, max);
                    return ceil(axisMax, mu);
                },

                getAxisMin: function(min, max) {
                    if (min == 0 && max == 0) {
                        return 0;
                    }

                    var axisMin;
                    if (min >= 0 && max >= 0) {
                        min = min == max ? 0 : min;

                        var diff = (max - min) / max;
                        if(diff > ZERO_THRESHOLD) {
                            return 0;
                        }

                        axisMin = min - ((max - min) / 2);
                    } else {
                        max = min == max ? 0 : max;
                        axisMin = min + 0.05 * (min - max);
                    }

                    var mu = this.getMajorUnit(min, max);
                    return floor(axisMin, mu);
                },
            };

            // Helper functions
            function supportsSVG() {
                return document.implementation.hasFeature(
                    "http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
            }

            function ceil(value, step) {
                return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);
            }

            function floor(value, step) {
                return round(Math.floor(value / step) * step, DEFAULT_PRECISION);
            }

            function round(value, precision) {
                var power = Math.pow(10, precision || 0);
                return Math.round(value * power) / power;
            }


            function CategoryAxis(surface, box, options) {
                this.element = surface.group();
                this.options = options;
                this.surface = surface;

                this.box = box;
                this.repaint();

                this.box = new Box(box.x1, box.y2 - this.element.height(), box.x2, box.y2);
            }

            $.extend(CategoryAxis.prototype, {
                repaint: function() {
                    var axis = this,
                        element = axis.element,
                        surface = axis.surface,
                        options = axis.options,
                        box = axis.box;

                    element.empty();

                    var totalWidth = box.width(),
                        step = totalWidth / options.categories.length,
                        y = box.y2,
                        currentX = (step / 2) + box.x1;
                    for(var i = 0; i < options.categories.length; i++) {
                        var text = surface.text(options.categories[i], element);

                        text.css(options.labels.style)
                            .attr("x", currentX - (text.width() / 2))
                            .attr("y", y);

                        vAlignText(text, "bottom");

                        currentX += step;
                    }

                    var lineY = axis.element.getBBox().y,
                        lineStyle = $.extend({}, options, { x1: box.x1, y1: lineY, x2: totalWidth, y2: lineY });

                    surface.line(lineStyle, axis.element);
                }
            });

            function Legend(surface, box, options) {
                var legend = this,
                    element = legend.element = surface.group();

                    legend.options = options;

                var y = 0;
                for(var i = 0; i < options.categories.length; i++) {
                    var text = surface.text(options.categories[i], element);

                    text.css(options.style)
                        .attr("x", 0)
                        .attr("y", y + (text.height() / 2));

                    vAlignText(text, "center");

                    y += text.height();
                }

                surface.rect({ x: 0, y: 0, width: element.width(), height: element.height(), stroke: "black", fill: "transparent" }, element);

                element.translate((box.width() - element.width()), ((box.height() - element.height()) / 2) + box.y1);

                legend.box = new Box(box.x2 - element.width(), box.y1, box.x2, box.y2);
            }

            function BarChart(surface, box, options) {
                // Determine scale
                var scale = box.height() / (options.max - options.min);

                // Determine category spacing
                var categoryStep = box.width() / options.data.length;

                // DrawingSurface each bar
                var barWidth = categoryStep / 3;

                // Start half-step forward to center the series
                var barCenterX = box.x1 + categoryStep / 2;
                var barBottomY = box.y2;
                for (var i = 0; i < options.data.length; i++) {
                    var value = options.data[i];
                    var barHeight = value * scale;
                    var barX = barCenterX - barWidth / 2;
                    var barY = barBottomY - barHeight;

                    var bar = surface.rect({ width: barWidth, height: barHeight, x: barX, y: barY, fill: "#4f81bd"});
                    barCenterX += categoryStep;
                }
            }

            function Chart(container, options) {
                var chart = this,
                    options = chart.options = $.extend(true, chart.defaults, options),
                    surface = new SVGSurface("#container");

                var currentBox = surface.box;

                // Render title
                var titleOptions = $.extend(true, {}, chart.defaults.title, options.title);
                if (titleOptions.text) {
                    var title = new ChartTitle(surface, currentBox, options.title);
                }

                var xAxisOptions = $.extend(true, {}, chart.defaults.xAxis, options.xAxis);
                if (options.xAxis.categories) {
                    var legendOptions = $.extend({}, chart.defaults.legend, options.legend, {
                        categories: xAxisOptions.categories
                    });

                    currentBox = boxDiff(currentBox, title.box);
                    var legend = new Legend(surface, currentBox, legendOptions);

                    currentBox = boxDiff(currentBox, legend.box);
                    var xAxis = new CategoryAxis(surface, currentBox, options.xAxis);
               }

                // Determine y-axis range
                var seriesMin = Number.MAX_VALUE,
                    seriesMax = Number.MIN_VALUE;
                $.each(options.series, function() {
                    seriesMin = Math.min(seriesMin, Math.min.apply(Math, this.data));
                    seriesMax = Math.max(seriesMax, Math.max.apply(Math, this.data));
                });

                // Render axises
                var yAxisOptions = $.extend(true, {}, chart.defaults.yAxis, options.yAxis, {
                    min: seriesMin,
                    max: seriesMax
                });
                currentBox = boxDiff(currentBox, xAxis.box);
                var yAxis = new NumericAxis(surface, currentBox, yAxisOptions);

                if (xAxis && yAxis) {
                    xAxis.box.x1 = xAxis.box.x1 + yAxis.box.width();
                    xAxis.repaint();
                }

                currentBox = boxDiff(currentBox, yAxis.box);

                // Render series
                $.each(options.series, function() {
                    var barChartOptions = {
                        min: yAxis.min,
                        max: yAxis.max,
                        data: this.data
                    };

                    var barChart = new BarChart(surface, currentBox, barChartOptions);
                });
            }

            $.extend(Chart.prototype, {
                defaults: {
                    title: {
                        text: "Title",
                        style: {
                            fontSize: "25px"
                        }
                    },

                    yAxis: {
                        labels: {
                            style: {
                                fontSize: "16px"
                            }
                        },
                        min: 0,
                        max: 1.2,
                        stroke: "black",
                        "stroke-width": ".5px"
                    },

                    xAxis: {
                        labels: {
                            style: {
                                fontSize: "16px"
                            }
                        },
                        stroke: "black",
                        "stroke-width": ".5px",
                        offsetLeft: 0,
                        offsetRight: 0
                    },

                    legend: {
                        style: {
                            fontSize: "16px"
                        }
                    }
                },

                seriesDefaults: {
                    type: "bar"
                }
            });

            $(document).ready(function() {
                var chart = new Chart($("#container"), {
                    series: [
                        { data: [ 100, 200, 300 ] }
                    ],
                    xAxis: {
                        categories: ["Alpha", "Beta", "Charlie"]
                    },
                    title: {
                        text: "Lovely Bars"
                    }
                });
            });

        </script>

        <div id="container" style="width: 800px; height: 400px; position: relative;">
        </div>

    </body>
</html>


