<!DOCTYPE html>
<html>
    <head>
        <title>Chart Playground</title>
        <script src="../src/jquery.js"></script>
        <script src="../src/kendo.core.js"></script>
        <script src="../src/kendo.chart.js"></script>
    </head>
    <body>
        <script type="text/javascript">
            var svgNS = "http://www.w3.org/2000/svg";

            var SVGPrimitive = function(element, surface) {
                this.surface = surface;
                this.element = $(element);
            }

            $.extend(SVGPrimitive.prototype, {
                text: function(value) {
                    this.element.text(value);
                    return this;
                },

                css: function() {
                    var that = this,
                        element = that.element;

                    element.css.apply(element, arguments);
                    return that;
                },

                attr: function(key, value) {
                    var that = this,
                        element = that.element;

                    if (typeof key == "string") {
                        if (typeof value != "undefined") {
                            element[0].setAttribute(key, value);
                        } else {
                            return element[0].getAttribute(key);
                        }
                    } else {
                        var map = key;
                        for (var attrKey in map) {
                            element[0].setAttribute(attrKey, map[attrKey]);
                        }
                    }

                    return that;
                },

                height: function(value) {
                    if (value) {
                        this.attr({ height: value });
                    } else {
                        return this.getBBox().height;
                    }
                },

                width: function(value) {
                    if (value) {
                        this.attr({ width: value });
                    } else {
                        return this.getBBox().width;
                    }
                },

                translate: function(dx, dy) {
                    this.attr({ transform: "translate(" + dx + ", " + dy + ")" });
                },

                getBBox: function() {
                    return this.element[0].getBBox();
                },

                getComputedStyle: function() {
                    return window.getComputedStyle(this.element[0]);
                },

                hAlign: function (hAlign, container) {
                    var width = this.width(),
                        x = this.attr("x"),
                        offsetX = 0,
                        container = container || this.surface.element,
                        parentWidth = container.width();

                    if (hAlign == "center") {
                        offsetX = (parentWidth - width) / 2;
                    }

                    this.attr("x", x + offsetX);

                    return this;
                }
            });

            var SVGSurface = function(container) {
                var that = this,
                    options = that.options = $.extend(SVGSurface.prototype.defaults, options),
                    container = $(container),
                    element = that.element = this._createElement("svg", container);

                container.append(element.element);

                this.rect({
                    x: 0,
                    y: 0,
                    width: container.width(),
                    height: container.height(),
                    fill: "transparent"
                }, element);
            }

            $.extend(SVGSurface.prototype, {
                defaults: {
                    width: "100%",
                    height: "100%"
                },

                group: function(parentElement) {
                    return this._createElement("g", parentElement);
                },

                desc: function(text, parentElement) {
                    var desc = this._createElement("desc", parentElement);
                    desc.text(text);

                    return desc;
                },

                text: function(text, parentElement) {
                    var textElement = this._createElement("text", parentElement);
                    textElement.text(text);

                    return textElement;
                },

                rect: function(options, parentElement) {
                    var rect = this._createElement("rect", parentElement);
                    rect.attr(options);

                    return rect;
                },

                _createElement: function(tagName, parentElement) {
                    var that = this,
                        parentNode = parentElement ? parentElement.element || parentElement : that.element.element,
                        element = document.createElementNS(svgNS, tagName);

                    parentNode.append(element);
                    return new SVGPrimitive(element, this);
                }
            });

            function ChartTitle(surface, options) {
                var title = this,
                    element = title.element = surface.group(),
                    desc = surface.desc("Chart Title", element);

                title.options = $.extend(true, options, title.defaults);

                var text = surface
                    .text(options.text, element)
                    .css(options.style)
                    .attr("y", 0)
                    .hAlign("center");

                vAlignText(text, "top");
            }

            $.extend(ChartTitle.prototype, {
                defaults: {
                    style: {
                        fontSize: "24px"
                    }
                },

                height: function() {
                    return this.element.height();
                }
            });

            // Aligns text vertically
            // Requires text primitive with set Y position
            function vAlignText(textPrimitive, vAlign) {
                    var bbox = textPrimitive.getBBox(),
                        y = parseInt(textPrimitive.attr("y")),
                        offsetY = 0,
                        textHeight = (y - bbox.y),
                        fontSize = parseInt(textPrimitive.getComputedStyle().fontSize);

                    if (vAlign == "center") {
                        offsetY = (textHeight / 2) - (bbox.height - fontSize);
                    } else if (vAlign == "top") {
                        offsetY = bbox.height;
                    }

                    textPrimitive.attr("y", y + offsetY);
            };

            // Numeric Axis
            var DEFAULT_PRECISION = 6,
                ZERO_THRESHOLD = 0.2;

            function NumericAxis(surface, options) {
                var axis = this,
                    element = axis.element = surface.group();

                var majorUnit = axis.getMajorUnit(options.min, options.max),
                    axisMax = axis.getAxisMax(options.min, options.max),
                    axisMin = axis.getAxisMin(options.min, options.max),
                    majorTicks = Math.round((axisMax - axisMin) / majorUnit) + 1;
            }

            NumericAxis.prototype = {
                getMajorUnit: function (min, max) {
                    var diff = max - min;
                    if (diff == 0) {
                        if (max == 0) {
                            return 0.1;
                        }

                        diff = Math.abs(max);
                    }

                    var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10))),
                        relativeValue = round((diff / scale), DEFAULT_PRECISION),
                        scaleMultiplier = 1;

                    if (relativeValue < 1.904762) {
                        scaleMultiplier = 0.2;
                    } else if (relativeValue < 4.761904) {
                        scaleMultiplier = 0.5;
                    } else if (relativeValue < 9.523809) {
                        scaleMultiplier = 1;
                    } else {
                        scaleMultiplier = 2;
                    }

                    return round(scale * scaleMultiplier, DEFAULT_PRECISION);
                },

                getAxisMax: function(min, max) {
                    if (min == 0 && max == 0) {
                        return 1;
                    }

                    var axisMax;
                    if (min <= 0 && max <= 0) {
                        max = min == max ? 0 : max;

                        var diff = Math.abs((max - min) / max);
                        if(diff > ZERO_THRESHOLD) {
                            return 0;
                        }

                        axisMax = max - ((min - max) / 2);
                    } else {
                        min = min == max ? 0 : min;
                        axisMax = max + 0.05 * (max - min);
                    }

                    var mu = this.getMajorUnit(min, max);
                    return ceil(axisMax, mu);
                },

                getAxisMin: function(min, max) {
                    if (min == 0 && max == 0) {
                        return 0;
                    }

                    var axisMin;
                    if (min >= 0 && max >= 0) {
                        min = min == max ? 0 : min;

                        var diff = (max - min) / max;
                        if(diff > ZERO_THRESHOLD) {
                            return 0;
                        }

                        axisMin = min - ((max - min) / 2);
                    } else {
                        max = min == max ? 0 : max;
                        axisMin = min + 0.05 * (min - max);
                    }

                    var mu = this.getMajorUnit(min, max);
                    return floor(axisMin, mu);
                },
            };

            // Helper functions
            function supportsSVG() {
                return document.implementation.hasFeature(
                    "http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
            }

            function ceil(value, step) {
                return round(Math.ceil(value / step) * step, DEFAULT_PRECISION);
            }

            function floor(value, step) {
                return round(Math.floor(value / step) * step, DEFAULT_PRECISION);
            }

            function round(value, precision) {
                var power = Math.pow(10, precision || 0);
                return Math.round(value * power) / power;
            }


            function CategoryAxis(surface, options) {
                var axis = this,
                    element = axis.element = surface.group();

                axis.options = $.extend(true, options, axis.defaults);

                for (var i = 0; i < options.categories.length; i++) {
                    var text = surface.text(options.categories[i], element);
                    
                }
            }

            $.extend(CategoryAxis.prototype, {
                defaults: {
                    categories: []
                },

                height: function() {
                    return this.element.height();
                }
            });

            function BarChart(surface, options) {
            }

            function Chart(container, options) {
                var chart = this,
                    options = chart.options = $.extend(true, options, chart.defaults),
                    surface = new SVGSurface("#container");

                // Render title
                if (options.title) {
                    var title = new ChartTitle(surface, options.title);
                }

                // Determine y-axis range
                var seriesMin = Number.MAX_VALUE,
                    seriesMax = Number.MIN_VALUE;
                $.each(options.series, function() {
                    seriesMin = Math.min(seriesMin, Math.min.apply(Math, this.data));
                    seriesMax = Math.max(seriesMax, Math.max.apply(Math, this.data));
                });

                // Render axises
                yAxisOptions = $.extend(true, {}, chart.defaults.yAxis, options.yAxis, {
                    min: seriesMin,
                    max: seriesMax
                });
                var yAxis = new NumericAxis(surface, yAxisOptions);

                if (options.xAxis.categories) {
                    //var xAxis = new CategoryAxis(surface, options.xAxis);
                }

/*
                // Render series
                $.each(options.series, function() {
                    $.extend(this, chart.seriesDefaults);

                    var series = new BarChart(surface, {
                        data: this.data
                    });
                });
*/
            }

            $.extend(Chart.prototype, {
                defaults: {
                    title: {
                        text: "Title"
                    },

                    yAxis: {
                        min: 0,
                        max: 1.2
                    }
                },

                seriesDefaults: {
                    type: "bar"
                }
            });

            $(document).ready(function() {
                var chart = new Chart($("#container"), {
                    series: [
                        { data: [ 100, 200, 300 ] }
                    ],
                    xAxis: {
                        categories: ["A", "B", "C"]
                    },
                    title: {
                        text: "Lovely Bars"
                    }
                });
            });

/*
            var DrawingSurface = function(container, options) {
                var that = this;
                that.options = $.extend(DrawingSurface.prototype.defaults, options);

                // Prepare drawing surface
                var svg = document.createElementNS(svgNS, "svg");
                svg.setAttributeNS(null, "width", that.options.width);
                svg.setAttributeNS(null, "height", that.options.height);
                $(container).append(svg);

                this._svg = svg;
                return this;
           };

            DrawingSurface.prototype = {
                defaults: {
                    width: "100%",
                    height: "100%"
                },

                width: function () {
                    return this._svg.parentNode.offsetWidth;
                },

                height: function() {
                    return this._svg.parentNode.offsetHeight;
                },

                rect: function(attributes) {
                    var rect = document.createElementNS(svgNS, "rect");
                    for (var attr in attributes) {
                        rect.setAttributeNS(null, attr, attributes[attr]);
                    }

                    this._svg.appendChild(rect);

                    return this;
                }
            };

            $(document).ready(function() {
                configuration = {
                    title: "Sample Chart",
                    series: [{
                        type: "bar",
                        name: "2003",
                        data: [175, 100, 300, 275]
                    }],
                    axisX: {
                        title: "Products",
                        labels: ["Excel", "Power Point", "Word", "Outlook"],
                    },
                    axisY: {
                        title: "Sales in $ mln."
                    },
                    legend: {
                        position: "bottom-right",
                        layout: "horizontal"
                    }
                };

                // Prepare drawing surface
                var d = new DrawingSurface("#container");
                var svg = d._svg;

                // Prepare to draw the bar chart
                var points = configuration.series[0].data;

                // Determine Y range 
                var minY = 0;
                var maxY = Math.max.apply(null, points);
                maxY = roundUp(maxY * 1.2); // Leave 10% margin and round up

                // Infer physical dimensions
                var width = d.width();
                var height = d.height();

                // Assume axises take 30 units, the rest is the plot area
                var plotOrigin = { x: 30, y: 0 };
                var plotWidth = width - 30;
                var plotHeight = height - 30;

                // Determine scale
                var scale = plotHeight / (maxY - minY);

                // Determine category spacing
                var categoryStep = plotWidth / points.length;

                // DrawingSurface a box around the chart area for debugging
                var chartBounds = d.rect({ "width": width, "height": height, "x": 0, "y": 0, "fill": "#fff", "stroke": "#f0a804"});

                // DrawingSurface a box around the plot area for debugging
                var plotBounds = d.rect({ "width": plotWidth, "height": plotHeight, "x": plotOrigin.x, "y": plotOrigin.y, "fill": "#fff", "stroke": "#f0a804"});
                
                // DrawingSurface each bar
                var barWidth = 60;
                // Start half-step forward to center the series
                var barCenterX = plotOrigin.x + categoryStep / 2;
                var barBottomY = plotOrigin.y + plotHeight;
                for (var i = 0; i < points.length; i++) {
                    var value = points[i];
                    var barHeight = value * scale;
                    var barX = barCenterX - barWidth / 2;
                    var barY = barBottomY - barHeight;

                    var bar = d.rect({ "width": barWidth, "height": barHeight, "x": barX, "y": barY, "fill": "#4f81bd"});
                    
                    barCenterX += categoryStep;
                }
            });

            // rounds to the nearest 10, 100, 1000, etc.
            function roundUp(number) {
                var scale = Math.pow(10, Math.max(Math.floor(Math.log(Math.abs(number)) / Math.log(10)) - 1, 1)),
                    base = number / scale;

                return (number > 0 ? Math.ceil(base) : Math.floor(base)) * scale;
            }

            function getMajorUnit(maxValue) {
                var scale = Math.pow(10, Math.max(Math.floor(Math.log(Math.abs(maxValue)) / Math.log(10)), 0));
                return scale * 0.2;
            }

            function getAxisMax(min, max) {
                if (min <= 0 && max <= 0) {
                    return min + 0.05 * (min - max);
                } else {
                    return max + 0.05 * (max - min);
                }
            }

            function getAxisMin(min, max) {
                var threshold = 1/6;

                if (min <= 0 && max <= 0) {
                    return min + 0.05 * (min - max);
                } else {
                    
                }
                }
*/

        </script>

        <div id="container" style="width: 800px; height: 400px; position: relative;">
        </div>

    </body>
</html>


