<!DOCTYPE html>
<html>
<head>
    <title>Surface sandbox</title>
    <script src="../../src/jquery.js"></script>
    <script src="../../src/kendo.core.js"></script>
    <script src="../../src/kendo.data.js"></script>
    <script src="../../src/kendo.dataviz.core.js"></script>
    <script src="../../src/kendo.dataviz.vml.js"></script>
    <script src="../../src/kendo.dataviz.svg.js"></script>
    <script src="../../src/kendo.dataviz.canvas.js"></script>
</head>
<body>
    <div id="wrap" style="width: 200px; height: 200px;"></div>
    <input type="button" value="Toggle ticks" onclick="toggleTicks()" />
    <input type="button" value="Toggle color" onclick="toggleColor()" />
    <input type="button" value="Stop" onclick="stop()" />
    <script>
    var SVG_NS = "http://www.w3.org/2000/svg",
        DEG_TO_RAD = Math.PI / 180;

    var doc = document,
        math = Math,
        noop = $.noop,
        proxy = $.proxy;

    var Class = kendo.Class,
        Observable = kendo.Observable,
        ObservableArray = kendo.data.ObservableArray,
        ObservableObject = kendo.data.ObservableObject;

    var dataviz = kendo.dataviz,
        append = dataviz.append,
        defined = dataviz.defined,
        renderSVG = dataviz.renderSVG,
        renderTemplate = dataviz.renderTemplate;

    // Primitives, public API
    var Group = ObservableObject.extend({
        init: function() {
            this.children = [];
            this.options = {};
            ObservableObject.fn.init.call(this, this);
        },

        append: function() {
            append(this.children, arguments);
        }
        // traverse
        // etc.
    });

    var Point = ObservableObject.extend({
        init: function(x, y) {
            var point = this;

            point.x = x || 0;
            point.y = y || 0;

            // Intentionally skip ObservableObject init
            // to avoid unnecessary wrapping
            Observable.fn.init.call(point, this);
        },

        rotate: function(center, degrees) {
            var point = this,
                theta = degrees * DEG_TO_RAD,
                cosT = math.cos(theta),
                sinT = math.sin(theta),
                cx = center.x,
                cy = center.y,
                x = point.x,
                y = point.y;

            point.x = cx + (x - cx) * cosT + (y - cy) * sinT;
            point.y = cy + (y - cy) * cosT - (x - cx) * sinT;

            point.trigger("change");

            return point;
        }
    });

    Path = ObservableObject.extend({
        init: function(points, options) {
            var path = this;

            path.points = points || [];
            path.options = options || {};

            ObservableObject.fn.init.call(path, this);
        }
    });

    // SVG Nodes, more or less private implementation detail
    var Node = ObservableObject.extend({
        init: function(source) {
            ObservableObject.fn.init.call(this, this);

            this.source = source;
            this.source.options.bind("change", proxy(this._setOptions, this));
        },

        render: function() {
            return this._template(this);
        },

        attachTo: function(domElement) {
            if (!this.element) {
                var container = doc.createElement("div");
                dataviz.renderSVG(container,
                    "<?xml version='1.0' ?>" +
                    "<svg xmlns='" + SVG_NS + "' version='1.1'>" +
                    this.render() +
                    "</svg>"
                );

                this.element = container.firstElementChild.lastChild;

                domElement.appendChild(this.element);
            }
        },

        detach: function() {
            var element = this.element;

            if (element) {
                element.parentNode.removeChild(element);
                this.element = null;
            }
        },

        _template: noop,

        _setOptions: noop
    });

    // TODO: Rethink method name & signature
    Node.load = function(primitives) {
        var result = [];

        for (var i = 0; i < primitives.length; i++) {
            var source = primitives[i];
            var children = source.children;
            var node;

            if (source instanceof Group) {
                node = new GroupNode(source);
            } else if (source instanceof Path) {
                node = new PathNode(source);
            }

            if (node.childNodes && children && children.length > 0) {
                append(node.childNodes, Node.load(children));
            }

            result.push(node);
        }

        return result;
    };

    var GroupNode = Node.extend({
        init: function(source) {
            this.childNodes = [];

            Node.fn.init.call(this, source);

            this.source.children.bind("change", proxy(this._childrenChange, this));
            this.childNodes.bind("change", proxy(this._childNodesChange, this));
        },

        attachTo: function(domElement) {
            var nodes = this.childNodes,
                i;

            Node.fn.attachTo.call(this, domElement);

            for (i = 0; i < nodes.length; i++) {
                nodes[i].element = this.element.childNodes[i];
            }
        },

        _template: renderTemplate(
            "<g>#= d._renderChildren() #</g>"
        ),

        _renderChildren: function() {
            var nodes = this.childNodes,
                output = "",
                i;

            for (i = 0; i < nodes.length; i++) {
                output += nodes[i].render();
            }

            return output;
        },

        // TODO: Rename
        _childrenChange: function(e) {
            var group = this;

            // TODO: Test different scenarios for synchronization
            if (e.action === "add") {
                append(group.childNodes, Node.load(e.items));
            } else if (e.action === "remove") {
                group.childNodes.splice(e.index, e.items.length);
            }
        },

        // TODO: Rename
        _childNodesChange: function(e) {
            for (var i = 0; i < e.items.length; i++) {
                var node = e.items[i];

                if (e.action === "add" && this.element) {
                    node.attachTo(this.element);
                } else if (e.action === "remove") {
                    node.detach();
                }
            }
        }
    });

    var PathNode = Node.extend({
        init: function(source) {
            Node.fn.init.call(this, source);

            this.source.points.bind("change", proxy(this._setPoints, this));
        },

        renderId: function() {
            var element = this,
                options = element.source.options,
                result = "";

            if (options.id) {
                result = element.renderAttr("id", options.id);
            }

            return result;
        },

        renderAttr: function (name, value) {
            return defined(value) ? " " + name + "='" + value + "' " : "";
        },

        renderPoints: function() {
            var path = this,
                points = path.source.points,
                i,
                result = [];

            for (i = 0; i < points.length; i++) {
                result.push(points[i].x + " " + points[i].y);
            }

            return "M" + result.join(" ");
        },

        _template: renderTemplate(
            "<path #= d.renderId() #" +
            //"style='display: #= d.renderDisplay() #; " +
            //"#= d.renderCursor() #' " +
            //"#= d.renderDataAttributes() # " +
            "d='#= d.renderPoints() #' " +
            "#= d.renderAttr(\"stroke\", d.source.options.stroke.color) # " +
            "#= d.renderAttr(\"stroke-width\", d.source.options.stroke.width) #" +
            //"#= d.renderDashType() # " +
            //"stroke-linecap='#= d.renderLinecap() #' " +
            //"stroke-linejoin='round' " +
            //"fill-opacity='#= d.options.fillOpacity #' " +
            //"stroke-opacity='#= d.options.strokeOpacity #' " +
            //"fill='#= d.renderFill() #'> " +
            "></path>"
        ),

        _setPoints: function(e) {
            if (this.element) {
                $(this.element).attr({
                    d: this.renderPoints()
                });
            }
        },

        _setOptions: function(e) {
            if (this.element) {
                // TODO: Mapping
                if (e.field === "fill.color") {
                    $(this.element).attr({
                        "fill": this.source.options.fill
                    });
                }
                if (e.field === "stroke.color") {
                    $(this.element).attr({
                        "stroke": this.source.options.stroke.color
                    });
                }
            }
        }
    });

    var Surface = Observable.extend({
        init: function(wrap, options) {
            Observable.fn.init.call(this);

            this.nodes = new ObservableArray([]);
            this.nodes.bind("change", proxy(this._nodeChange, this))

            renderSVG(wrap, this._template(this));
            this.element = wrap.firstElementChild;
        },

        options: {
            width: "100%",
            height: "100%"
        },

        events: [
            "click"
        ],

        append: function() {
            append(this.nodes, Node.load(arguments));
        },

        clear: function() {
            this.nodes.empty();
        },

        _template: renderTemplate(
            "<?xml version='1.0' ?>" +
            "<svg xmlns='" + SVG_NS + "' version='1.1' " +
            "width='#= d._renderSize(d.options.width) #' height='#= d._renderSize(d.options.height) #' " +
            "style='position: relative; display: #= d.display #;'></svg>"
        ),

        _nodeChange: function(e) {
            for (var i = 0; i < e.items.length; i++) {
                var node = e.items[i];
                if (e.action === "add") {
                    node.attachTo(this.element);
                } else if (e.action === "remove") {
                    node.detach();
                }
            }
        },

        _renderSize: function(size) {
            if (typeof size !== "string") {
                size += "px";
            }

            return size;
        }
    });

    // Demo

    var center = new Point(50,50);

    var seconds = new Path([center, new Point(50, 0)], {
        stroke: {
            color: "red",
            width: 1
        }
        // zIndex
        // etc.
    });

    var minutes = new Path([center, new Point(50, 5)], {
        stroke: {
            color: "black",
            width: 1
        }
    });

    var hours = new Path([center, new Point(50, 25)], {
        stroke: {
            color: "black",
            width: 1
        }
    });

    var ticks = new Group();
    var clock = new Group();
    clock.append(hours, minutes, seconds, ticks);

    var surface = new Surface($("#wrap")[0]);
    surface.append(clock);

    function addTicks() {
        for (var i = 0; i < 360; i += 30) {
            var p1 = new Point(50, 10).rotate(center, i);
            var p2 = new Point(50, 0).rotate(center, i);
            ticks.append(new Path([p1, p2], {
                stroke: {
                    color: "black",
                    width: 0.5
                }
            }));
        }
    }

    function removeTicks() {
        ticks.children.empty();
    }

    function toggleTicks() {
        if (ticks.children.length === 0) {
            addTicks();
        } else {
            removeTicks();
        }
    }

    function toggleColor() {
        var stroke = seconds.options.stroke;
        if (stroke.color === "red") {
            stroke.set("color", "blue");
        } else {
            stroke.set("color", "red");
        }
    }

    var interval = setInterval(function() {
        seconds.points[1].rotate(center, -6);
        minutes.points[1].rotate(center, -0.1);
        hours.points[1].rotate(center, -0.0017);
    }, 10);

    function stop() {
        clearInterval(interval)
        surface.clear();
    }
    </script>
</body>
</html>

