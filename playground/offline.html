<!DOCTYPE html>
<html>
    <head>
        <link href="http://cdn.kendostatic.com/2014.2.716/styles/kendo.common.min.css" rel="stylesheet" type="text/css" />
        <link href="http://cdn.kendostatic.com/2014.2.716/styles/kendo.default.min.css" rel="stylesheet" type="text/css" />
        <link href="http://cdn.kendostatic.com/2014.2.716/styles/kendo.default.mobile.min.css" rel="stylesheet" type="text/css" />
        <link href="http://cdn.kendostatic.com/2014.2.716/styles/kendo.dataviz.default.min.css" rel="stylesheet" type="text/css" />
        <script src="loader.js"></script>
        <script>
            requireSync([
            "../src/jquery",
            "../src/kendo.grid",
            "../src/kendo.notification",
            "../src/kendo.mobile.switch"
            ]);
        </script>
    </head>
    <body>
        Online: <input id="online" type="checkbox" checked>
        <div id="grid"></div>
        <div id="notification"></div>
        <script>

            var online = true;

            if (localStorage["online"] == "false") {
                $("#online").removeAttr("checked");
                online = false;
            }

            $("#online").kendoMobileSwitch({
                value: Boolean(localStorage["online"]),
                change: function() {
                    online = this.value();

                    localStorage.setItem("online", online);

                    if (online) {
                        notification.success("Online");
                    } else {
                        notification.success("Offline");
                    }
                }
            });

            var notification = new kendo.ui.Notification("#notification", {
                width: "50%",
                autoHideAfter: 1000,
                position: {
                    top: 0,
                    right: 0
                }
            });

            var OfflineTransport = kendo.data.RemoteTransport.extend({
                sync: function() {
                    if (localStorage.getItem("grid")) {
                        var state = JSON.parse(localStorage.getItem("grid"));

                        if (!state.requests) return;

                        notification.success(kendo.format("Sync {0} requests", state.requests.length));

                        var promises = [];

                        for (var req = 0; req < state.requests.length; req++) {
                            var request = state.requests[req];

                            if (request.type == "update") {
                                var promise = kendo.data.RemoteTransport.fn.update.call(this, request.options);
                                promises.push(promise);
                            }
                        }

                        $.when.apply(null, promises)
                              .then(function() {
                                  notification.success("Removing items from localStorage");
                                  localStorage.removeItem("grid");
                              });
                    }
                },
                store: function(type, options) {
                    var state = { requests: [] };

                    if (localStorage.getItem("grid")) {
                        state = JSON.parse(localStorage.getItem("grid"));
                    }

                    if (!state.requests) {
                        state.requests = [];
                    }

                    state.requests.push({
                        type: type,
                        options: options
                    });

                    localStorage.setItem("grid", JSON.stringify(state));
                },
                data: function(data) {
                    if (data !== undefined) {
                        var state = { };

                        if (localStorage.getItem("grid")) {
                            state = JSON.parse(localStorage.getItem("grid"));
                        }

                        state.data = data;

                        localStorage.setItem("grid", JSON.stringify(state));
                    } else {
                        var state = { };

                        if (localStorage.getItem("grid")) {
                            state = JSON.parse(localStorage.getItem("grid"));
                        }

                        return state.data;
                    }
                },
                read: function(options) {
                    var success = options.success || noop;

                    if (online) {
                        kendo.data.RemoteTransport.fn.read.call(this, options);
                    } else {
                        options.success(this.data());
                    }
                },
                update: function(options) {
                    if (online) {
                        this.sync();

                        return kendo.data.RemoteTransport.fn.update.call(this, options);
                    } else {
                        notification.success("Storing update requests in localStorage");

                        this.store("update", options);

                        return $.Deferred(function(deferred) {
                            options.success();
                        }).promise();
                    }
                }
            });

            function url(operation) {
                return function() {
                    return "http://demos.telerik.com/kendo-ui/service/products" + operation;
                }
            }

            var OfflineDataSource = kendo.data.DataSource.extend({
                success: function(data) {
                    var that = this,
                    options = that.options;

                    that.trigger("requestend", { response: data, type: "read" });

                    if (online) {
                        data = that.reader.parse(data);

                        that.transport.data(data);

                        if (that._handleCustomErrors(data)) {
                            that._dequeueRequest();
                            return;
                        }

                        that._total = that.reader.total(data);

                        if (that._aggregate && options.serverAggregates) {
                            that._aggregateResult = that.reader.aggregates(data);
                        }

                        data = that._readData(data);
                    } else {
                        that._total = data.length;
                    }

                    that._pristineData = data.slice(0);
                    that._pristineTotal = that._total;

                    that._data = that._observe(data);

                    that._addRange(that._data);

                    that._process(that._data);
                    that._dequeueRequest();
                },
                sync: function() {
                    var that = this,
                    idx,
                    length,
                    created = [],
                    updated = [],
                    destroyed = that._destroyed,
                    data = that._flatData(that._data);

                    if (!that.reader.model) {
                        return;
                    }

                    for (idx = 0, length = data.length; idx < length; idx++) {
                        if (data[idx].isNew()) {
                            created.push(data[idx]);
                            } else if (data[idx].dirty) {
                            updated.push(data[idx]);
                        }
                    }

                    var promises = that._send("create", created);

                    promises.push.apply(promises ,that._send("update", updated));
                    promises.push.apply(promises ,that._send("destroy", destroyed));

                    $.when.apply(null, promises)
                    .then(function() {
                        var idx, length;

                        for (idx = 0, length = arguments.length; idx < length; idx++){
                            that._accept(arguments[idx]);
                        }

                        that._change({ action: "sync" });

                        that.transport.data(that.data());

                        that.trigger("sync");
                    });
                }
            });


            var dataSource = new OfflineDataSource({
                transport: new OfflineTransport({
                    read:  {
                        url: url(""),
                        dataType: "jsonp"
                    },
                    update: {
                        url: url("/update"),
                        dataType: "jsonp"
                    },
                    destroy: {
                        url: url("/destroy"),
                        dataType: "jsonp"
                    },
                    create: {
                        url: url("/create"),
                        dataType: "jsonp"
                    },
                    parameterMap: function(options, operation) {
                        if (operation !== "read" && options.models) {
                            return {models: kendo.stringify(options.models)};
                        }
                    }
                }),
                batch: true,
                pageSize: 20,
                schema: {
                    model: {
                        id: "ProductID",
                        fields: {
                            ProductID: { editable: false, nullable: true },
                            ProductName: { validation: { required: true } },
                            UnitPrice: { type: "number", validation: { required: true, min: 1} },
                            Discontinued: { type: "boolean" },
                            UnitsInStock: { type: "number", validation: { min: 0, required: true } }
                        }
                    }
                }
            });

            $("#grid").kendoGrid({
                dataSource: dataSource,
                pageable: {
                    refresh: true
                },
                height: 550,
                toolbar: [ "save" ],
                columns: [
                    "ProductName",
                    { field: "UnitPrice", title: "Unit Price", format: "{0:c}", width: "120px" },
                    { field: "UnitsInStock", title:"Units In Stock", width: "120px" },
                    { field: "Discontinued", width: "120px" },
                    { command: ["edit"], title: "&nbsp;", width: "200px" }
                ],
                editable: "inline"
            });
        </script>
    </body>
</html>
