<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" >
        <title>Spline</title>
        <link href="http://cdn.kendostatic.com/2014.2.903/styles/kendo.common.min.css" rel="stylesheet" />
        <link href="http://cdn.kendostatic.com/2014.2.903/styles/kendo.rtl.min.css" rel="stylesheet" />
        <link href="http://cdn.kendostatic.com/2014.2.903/styles/kendo.silver.min.css" rel="stylesheet" />
        <link href="http://cdn.kendostatic.com/2014.2.903/styles/kendo.silver.mobile.min.css" rel="stylesheet" />
        <link href="http://cdn.kendostatic.com/2014.2.903/styles/kendo.dataviz.min.css" rel="stylesheet" />
        <link href="http://cdn.kendostatic.com/2014.2.903/styles/kendo.dataviz.silver.min.css" rel="stylesheet" />

        <script src="../src/jquery.js"></script>
        <script src="../src/kendo.core.js"></script>
        <script src="../src/kendo.color.js"></script>

        <script src="../src/kendo.data.js"></script>
        <script src="../src/kendo.binder.js"></script>

        <script src="../src/kendo.popup.js"></script>
        <script src="../src/kendo.userevents.js"></script>
        <script src="../src/kendo.draganddrop.js"></script>
        <script src="../src/kendo.slider.js"></script>
        <script src="../src/kendo.colorpicker.js"></script>
        <script src="../src/kendo.button.js"></script>
        <script src="../src/kendo.numerictextbox.js"></script>
        <script src="../src/kendo.list.js"></script>
        <script src="../src/kendo.dropdownlist.js"></script>


        <script src="../src/kendo.dataviz.core.js"></script>

         <script src="../src/util/main.js"></script>
         <script src="../src/mixins/observers.js"></script>
         <script src="../src/geometry/main.js"></script>
         <script src="../src/drawing/core.js"></script>
         <script src="../src/drawing/mixins.js"></script>
         <script src="../src/drawing/shapes.js"></script>
         <script src="../src/drawing/parser.js"></script>
         <script src="../src/drawing/svg.js"></script>
         <script src="../src/drawing/canvas.js"></script>
         <script src="../src/drawing/vml.js"></script>
    </head>
    <body >
        <style>
            .defaultMargin {
                margin: 5px;
            }
        </style>
        <script type="text/kendo" id="stopEditor">
            <div class = "defaultMargin">
               <h4>Stops</h4>
               <div>
                    <button type="button" data-role="button" data-bind="click:addStop">Add At</button>
                    <input data-role="numerictextbox" data-decimals="0" data-format="n0" style="width:80px" data-bind="value:newStopIndex" />
                </div>
                <div data-bind="source:stops" data-template="stopTemplate"></div>
            </div>
        </script>
        <script type="text/kendo" id="pointTemplate">
            <div class = "defaultMargin">
                <label data-bind="text:label"></label>
                ( <input data-role="numerictextbox" min="0" max="1" data-spinners="false" data-format="n1" style="width:50px" data-bind="value:x, events: {change: pointChange}" />,
                <input data-role="numerictextbox" min="0" max="1" data-spinners="false" data-format="n1" style="width:50px" data-bind="value:y, events: {change: pointChange}" /> )
            </div>
        </script>

        <script type="text/kendo" id="stopTemplate">
            <div class = "defaultMargin">
                <label>Color</label>
                <input data-role="colorpicker" data-bind="value:color, events: {change: colorChange}" />
                <label style="margin-left:10px;">Offset</label>
                <input data-role="numerictextbox" min="0" max="1" data-spinners="false" data-format="n1" style="width:50px" data-bind="value:offset, events: {change: offsetChange}" />
                <label style="margin-left:10px;">Opacity</label>
                <input data-role="numerictextbox" min="0" max="1" data-spinners="false" data-format="n1" style="width:50px" data-bind="value:opacity, events: {change: opacityChange}" />
                <button type="button" data-role="button" data-bind="click:removeStop">Remove</button>
            </div>
        </script>
        <script type="text/kendo" id="fillTemplate">
            <div class = "defaultMargin">
               #if (type == "linear") {#
                    <h3>Linear Gradient</h3>
                    <div data-bind="source:start" data-template="pointTemplate"></div>
                    <div data-bind="source:end" data-template="pointTemplate"></div>
                    #= $("\#stopEditor").html()#
               #} else if (type == "radial") {#
                    <h3>Radial Gradient</h3>
                    <div class = "defaultMargin">
                        <label>Radius</label>
                        <input data-role="numerictextbox" min="0" max="1" data-bind="value:radius, events: {change: radiusChange}"  />
                    </div>
                    <div data-bind="source:center" data-template="pointTemplate"></div>
                    #= $("\#stopEditor").html()#
               # } else {#
                    <label>Color</label>
                    <input data-role="colorpicker" data-bind="value:color, events: {change: fillColorChange}" />
               #}#
            </div>
        </script>

        <div id="fillContainer" style="float:left;margin-right:100px;">
            <label>Fill type</label>
            <input data-role="dropdownlist" data-bind="value: fillType, source: types, events: {change: fillChange}" data-value-field="type" data-text-field="type"/>
            </hr>
            <div data-bind="source: fillType" data-template="fillTemplate"></div>
        </div>
        <!--
            <textarea id="pathString" cols="40" rows="5" data-bind="value:path"></textarea>
            <div data-bind="text:drawPath"></div>

         -->
          <div id="container" style="float:left;"></div>
       <!--
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1200px" height="1200px" style="position:absolute;">
            <g>
                <path data-bind="attr: {d: path}" stroke="red" stroke-width="2" stroke-linecap="square" fill="none" stroke-linejoin="round"></path>
            </g>
        </svg>
      -->
        <!--
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1200px" height="1200px" style="position:absolute;left: 300px;">
            <g transform = "translate(0, 300)">
                <path d="M100,100 C200,200 300,200 400,100 L500,150 C450,200 200,300 100,200 z" transform = "rotate(-45 100 100) scale(1.1, 0.7)" stroke="red" stroke-width="2" stroke-linecap="square" fill="none" stroke-linejoin="round"></path>
            </g>
        </svg>
          -->
         <!--
         <div id="test"></div>
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1200px" height="1200px" style="position:absolute; left: 300px;">
            <g>
                <path d="M 300 300 v 86.6 h-25 A 50 100 0 1 1 350 300 c -5 100 100 100 100 -100 10 -70 50 100 50 100" stroke="red" stroke-width="2" stroke-linecap="square" fill="none" stroke-linejoin="round"></path>
            </g>
        </svg>
         -->
        <--
            <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="400px" height="400px" style="position:absolute;">
                <g>
                    <path d="M400 300 A 100 50 0 1 1 250 256.7" stroke="red" stroke-width="2" stroke-linecap="square" fill="none" stroke-linejoin="round"></path>
                    <circle cx="300" cy="300" r="3" stroke="black" stroke-width="2" stroke-linecap="square" fill="none"></circle>
                </g>
            </svg>
        -->
     <!--
        <svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="700px" height="700px" style="position: absolute;">
            <g transform="scale(2,1)">
                <circle cx="300" cy="300" r="100" transform="rotate(30)" stroke="red" stroke-width="2" stroke-linecap="square" fill="none" stroke-linejoin="round" />
                <circle cx="300" cy="300" r="3" stroke="black" stroke-width="2" stroke-linecap="square" fill="none"></circle>
            </g>
        </svg>
      -->
        <script>
            //test curve M100 100 c 50 50 100 0 200 0 200 10 0 100 -50 100
            //test arc M275 386.6 A 50 100 0 0 0 350 300
            var dataviz = kendo.dataviz,
                geometry = kendo.geometry,
                transform = geometry.transform,
                Point = geometry.Point,
                Circle = geometry.Circle,
                drawing = kendo.drawing,
                Path = drawing.Path,
                Group = drawing.Group,
                Rect = geometry.Rect,
                MultiPath = drawing.MultiPath,
                Segment = drawing.Segment,
                Surface = drawing.Surface,
                surface = Surface.create(document.getElementById("container"), {width: 400, height: 400, type: "svg"}),
                circleGeometry = new Circle(Point.create(150, 400), 100),
                circle = new drawing.Circle(circleGeometry, {fill: {color: "red"} }),
               // boundingRect = circle.bbox(),
                strokeOptions = {stroke: {color: "black", width: 2}},
                //circleBoundingPath = rectPath(boundingRect, strokeOptions),
                curve = new Path(strokeOptions),
                group = new drawing.Group(),
                mainGroup;

            var arcGeometry = new geometry.Arc(Point.create(300, 300), {
                startAngle: 120,
                endAngle: 0,
                radiusX: 50,
                radiusY: 100,
                counterClockwise: false
            });
//M300 340 C 286 340 272.1 338.1 260 334.6
            var arc = new drawing.Arc(arcGeometry, strokeOptions);
            //group.append(arc, new drawing.Circle(new geometry.Circle(Point.create(300, 300), 3), strokeOptions), rectPath(arc.bbox(), strokeOptions));//circle, circleBoundingPath, curve, curveBoundingRect);
            //surface.draw(group);
            var viewModel = kendo.observable({
                path: "M100,100T 200,200 t50,0 -100,100",//"M 300 300 v 86.6 h-25 A 50 100 0 1 1 350 300 c -5 100 100 100 100 -100 10 -70 50 100 50 100",//"M 300 300 A 50 100 0 1 1 350 300"
                drawPath: function() {
                    var pathString = this.get("path");
                    if (pathString) {
                        // var multiPath = Path.parse(pathString, strokeOptions),
                            // multiPathGroup =  new drawing.Group(),
                            // multiPathBoundingRect = multiPath.bbox();

                       // multiPathGroup.append(multiPath);//, rectPath(multiPathBoundingRect, strokeOptions));
                       // surface.clear();
                       // surface.draw(multiPathGroup);
                    }

                    return pathString;
                }
            });

            //gradientTest();

            function gradientTest() {
                var circleGeometry = new Circle(Point.create(200, 200), 100);
                //circle = new drawing.Circle(circleGeometry);
                circle = Path.fromRect(new geometry.Rect([50, 50], [200, 400]));
                surface.draw(circle);
                var viewModel = kendo.observable({
                    types: [{
                        type: "linear",
                        stops: [{
                            offset: 0.3,
                            color: "#FFFB2B",
                            opacity: 1
                        }, {
                            offset: 0.7,
                            color: "#3A58FF",
                            opacity: 1
                        }],
                        start: {
                            label: "Start",
                            x: 0,
                            y: 0
                        },
                        end: {
                            label: "End",
                            x: 1,
                            y: 0
                        },
                        newStopIndex: 0
                    }, {
                        type: "radial",
                        stops: [{
                            offset: 0.3,
                            color: "#FFFB2B",
                            opacity: 1
                        }, {
                            offset: 0.7,
                            color: "#3A58FF",
                            opacity: 1
                        }],
                        center: {
                            label: "Center",
                            x: 0.3,
                            y: 0.3
                        },
                        radius: 1,
                        newStopIndex: 0
                    }, {
                        type: "color",
                        color: "#FF3328"
                    }],

                    setLinearGradient: function() {
                        var linear = this.get("fillType");
                        var start = linear.start;
                        var end = linear.end;
                        circle.fill(new drawing.LinearGradient({
                            stops: this.get("fillType.stops").toJSON(),
                            start: [start.x, start.y],
                            end: [end.x, end.y]
                        }));
                    },

                    setRadialGradient: function() {
                        var radial = this.get("fillType");
                        var center = radial.center;
                        var radius = radial.radius;
                        circle.fill(new drawing.RadialGradient({
                            stops: this.get("fillType.stops").toJSON(),
                            center: [center.x, center.y],
                            radius: radius
                        }));
                    },

                    setFill: function() {
                        circle.fill(this.get("fillType.color"));
                    },

                    createStop: function(stop) {
                        return new drawing.GradientStop(stop.offset, stop.color, stop.opacity);
                    },

                    fillChange: function() {
                        var fill = this.get("fillType.type");
                        if (fill == "linear") {
                            this.setLinearGradient();
                        } else if (fill == "radial") {
                            this.setRadialGradient();
                        } else {
                            this.setFill();
                        }
                    },

                    addStop: function() {
                        var index = this.get("fillType.newStopIndex") || 0;
                        var gradient = circle.fill();
                        var stops = this.get("fillType.stops");
                        var stop = {
                            color: "#fff",
                            offset: 0,
                            opacity: 1
                        };
                        stops.splice(index, 0, stop);
                        gradient.stops.splice(index, 0, this.createStop(stop));
                    },

                    removeStop: function(e) {
                        var gradient = circle.fill();
                        var stops = this.get("fillType.stops");
                        var index = stops.indexOf(e.data);
                        stops.splice(index, 1);
                        gradient.stops.splice(index, 1);
                    },

                    pointChange: function(e) {
                        var gradient = circle.fill();
                        var item = e.data;
                        var fieldName = item.label.toLowerCase();

                        gradient[fieldName]([item.x, item.y]);
                    },

                    radiusChange: function(e) {
                        var gradient = circle.fill();
                        gradient.radius(e.data.radius);
                    },

                    offsetChange: function(e) {
                        var gradient = circle.fill();
                        var item = e.data;
                        var index = e.data.parent().indexOf(e.data);
                        gradient.stops[index].offset(item.offset);
                    },

                    colorChange: function(e) {
                        var gradient = circle.fill();
                        var item = e.data;
                        var index = e.data.parent().indexOf(e.data);

                        gradient.stops[index].color(item.color);
                    },

                    opacityChange: function(e) {
                        var gradient = circle.fill();
                        var item = e.data;
                        var index = e.data.parent().indexOf(e.data);
                        gradient.stops[index].opacity(item.opacity);
                    },

                    fillColorChange: function(e) {
                        circle.fill(e.data.color);
                    }
                });

                viewModel.set("fillType", viewModel.types[0]);
                viewModel.fillChange();
                kendo.bind($("#fillContainer"),  viewModel);


            }

            function updateGradient() {
                debugger;
                circle.fill(null);
            }

            //clipTest();
            function clipTest() {
                clip = new geometry.ClipRect(new Point(100, 100), new geometry.Size(150, 150));
                var circleGeometry = new Circle(Point.create(250, 200), 100);
                circle = new drawing.Circle(circleGeometry, {stroke: {color: "red", width: 3},
                     clip: clip
                });
                circle.transform(transform().translate(100, 100));
                var circleGeometry2 = new Circle(Point.create(300, 200), 100);
                circle2 = new drawing.Circle(circleGeometry2, {stroke: {color: "red", width: 3}});
                circle2.clip(clip);

                var group = new drawing.Group({});
                group.append(circle);
                group.append(circle2);
                // surface.clear();
                setTimeout(function() {
                    surface.draw(group);
                });
            }

            function updateRect() {
                // circle.clip(null);
                // setTimeout(function() {
                    // circle.clip(new geometry.ClipRect(new Point(100, 100), new geometry.Size(150, 150)));
                // }, 500);
                // circle2.clip(null);
                //circle.clip(null);
                circle.clip(new geometry.ClipRect(new Point(100, 100), new geometry.Size(250, 150)));
                //clip.size.setHeight(200);
            }

            //imageTest();

            function imageTest() {
                var group = new Group();
                var image = new drawing.Image("telerik.jpg", new geometry.Rect(new Point(100, 100), new Point(200, 200)));
                group.append(image);
                image.transform(transform().rotate(-45, 200, 200));
                var bbox = image.bbox();
                group.append(rectPath(bbox, strokeOptions));
                surface.draw(group);
            }

            //removeTest();
            function removeTest() {
                var group = new drawing.Group({});
                var options = {fill: {color: "lightgreen"}, stroke: {color: "black", width: 1}};
                for (var i = 0; i <= 5; i++) {
                    var rect = new geometry.Rect(new Point(i * 10, i * 10), new Point(i * 10 + 100, i * 10 + 100));
                    group.append(rectPath(rect, options));
                }

                surface.draw(group);

                window.removeChild = function(index) {
                    group.remove(group.children[index]);
                };
            }

            //pathArcTest();

            function pathArcTest() {
                var path = new Path();
                path.moveTo(200, 100);      
             
                path.arc(30, 180, 100, 100);
                surface.draw(path);
            }

            arcRotation();
            function arcRotation() {
                // var path = new Path();
                // path.moveTo()
                //var multiPath = Path.parse("M400 300 A 100 50 90 1 1 250 256.7", strokeOptions);
                    // multiPathGroup =  new drawing.Group(),
                    // multiPathBoundingRect = multiPath.bbox();
                var path = new Path(strokeOptions);
                path.moveTo(400, 300);
                path.arcTo(new Point(250, 256.7), 100, 50, true, true);
               // multiPathGroup.append(multiPath);//, rectPath(multiPathBoundingRect, strokeOptions));
               // surface.clear();
                surface.draw(path);
                // arcGeometry = new geometry.Arc(Point.create( 324.9999998796655, 278.35000166745266), {
                    // startAngle: -81.78702757281499,
                    // endAngle: 180.00000147877932,
                    // radiusX: 151.55435493577875,
                    // radiusY: 75.77717746788937,
                    // anticlockwise: false,
                    // xAxisRotation: 90
                // });
                // arc = new drawing.Arc(arcGeometry, strokeOptions);
                // surface.draw(arc);
            }
            //arcTransformTest();
            function arcTransformTest() {
                arcGeometry = new geometry.Arc(Point.create(200, 500), {
                    startAngle: 90,
                    endAngle: 240,
                    radiusX: 50,
                    radiusY: 100,
                    counterClockwise: false
                });
                arc = new drawing.Arc(arcGeometry, $.extend({transform: transform().scale(1,2).rotate(-45).scale(2,1).matrix()}, strokeOptions));
                var group = new drawing.Group({transform: transform().translate(-100,100).matrix()});
                group.append(arc, rectPath(arc.bbox(), strokeOptions));
                surface.clear();
                surface.draw(group);
            }

          //  parentTransformationsTest();
            function parentTransformationsTest() {
                var group = new Group({transform: transform().scale(2,1).matrix()}),
                    mainGroup = new Group({transform: transform().scale(1,2).matrix()}),
                    path = new Path({transform: transform().translate(10,10).matrix()});
                //path.moveTo(0,0);
                mainGroup.append(group);
                group.append(path);
               // debugger;
                group.bbox();
            }

           // multipathTransformTest();
            function multipathTransformTest() {
                var curveTransform = new MultiPath($.extend({transform: transform().translate(100,400).scale(1.5,1).rotate(-90, 100, 100).matrix()}, strokeOptions));
                curveTransform.moveTo(100, 100);
                curveTransform.curveTo(Point.create(200, 200), Point.create(300, 200), Point.create(400, 100));
                curveTransform.lineTo(500, 150);
                curveTransform.curveTo(Point.create(550, 200), Point.create(200, 300), Point.create(100, 200));
                curveTransform.close();

                curveTransform.moveTo(50, 200);
                curveTransform.curveTo(Point.create(150, 190),
                        Point.create(150, 130),
                        Point.create(70, 80));
                curveTransform.lineTo(50, 100);
                curveTransform.lineTo(50, 200);
                var group = new drawing.Group();
                group.append(curveTransform, rectPath(curveTransform.bbox(), strokeOptions));

                surface.clear();
                surface.draw(group);
            }


            //circleTransformTest();
            function circleTransformTest() {
                var m = transform().scale(1,2).rotate(30).translate(500,-500).matrix();
                circleGeometry = new Circle(Point.create(250, 200), 100);
                var original = new drawing.Circle(circleGeometry, {stroke: {color: "red", width: 3}});
                circle = new drawing.Circle(circleGeometry, {stroke: {color: "red", width: 3}, transform: m});
                circleCenter = new drawing.Circle(new Circle(Point.create(150, 400), 2), {stroke: {color: "red", width: 3}, transform: m})
                    //});
                group = new drawing.Group({});
                group.append(circle);
                mainGroup = new drawing.Group();
                mainGroup.append(group, rectPath(group.bbox(), strokeOptions), original);

                surface.clear();
                surface.draw(mainGroup);
            }

            function testChange() {
                circleGeometry.setRadius(20);
            }

            //curveTransformTest();
            function curveTransformTest() {
                curveTransform = new Path($.extend({transform: transform().translate(0, 100).scale(1,2).rotate(-45, 100, 100).scale(1.1, 0.7).matrix()}, strokeOptions));
                original = new Path({stroke: {color: "blue", width: 1}});
                testing = curveTransform;
                curveTransform.moveTo(100, 100);
                curveTransform.curveTo(Point.create(200, 200), Point.create(300, 200), Point.create(400, 100));
                curveTransform.lineTo(500, 150);
                curveTransform.curveTo(Point.create(450, 200), Point.create(200, 300), Point.create(100, 200));
                curveTransform.close();

                original.moveTo(100, 100);
                original.curveTo(Point.create(200, 200), Point.create(300, 200), Point.create(400, 100));
                original.lineTo(500, 150);
                original.curveTo(Point.create(450, 200), Point.create(200, 300), Point.create(100, 200));
                original.close();
                group = new drawing.Group({transform: transform().translate(0, 300).matrix()});
                group.append(curveTransform, rectPath(curveTransform.bbox(), strokeOptions));
                surface.clear();

                mainGroup = new drawing.Group();
                mainGroup.append(group, original);
                surface.draw(mainGroup);
            }

           //kendo.bind($("body"), viewModel);

            function rectPath(rect, options) {
                var rectPath = new Path(options),
                    width = rect.width(),
                    height = rect.height(),
                    origin = rect.origin;
                rectPath.moveTo(origin.x, origin.y);
                rectPath.lineTo(origin.x + width, origin.y);
                rectPath.lineTo(origin.x + width, origin.y + height);
                rectPath.lineTo(origin.x, origin.y + height);
                rectPath.close();

                return rectPath;
            }
            //renderTest();
            function renderTest() {
                var surface = Surface.create(document.getElementById("test"), {width: 700, height: 700}),
                    arcGeometry = new geometry.Arc(Point.create(100, 100), {
                        startAngle: 60,
                        endAngle: 240,
                        radiusX: 50,
                        radiusY: 100,
                        counterClockwise: false
                    }),
                    arc = new drawing.Arc(arcGeometry, {stroke: {color: "red", width: 20}});
                //var circ  =new drawing.Circle(new geometry.Circle(Point.create(300, 300), 100), {stroke: {color: "red", width: 100}});
                var group = new drawing.Group();

                //group.append(arc, rectPath(arc.bbox(), {stroke: {color: "black", width: 1}}));
               // group.append(circ, rectPath(circ.bbox(), {stroke: {color: "black", width: 1}}));

                var path = new Path({stroke: {color: "red", width: 1}});
                path.moveTo(0, 0);
                path.curveTo(new Point(-10, -10), new Point(-20, 30), new Point(30, 50));
                //path.curveTo(new Point(310, 50), new Point(400, 150), new Point(200, 300));
                // path.close();
                // var path2 = new Path({stroke: {color: "black", width: 1}});
                // path2.moveTo(100, 100);
                // path2.curveTo(new Point(150, 150), new Point(200, 150), new Point(300, 100));
                // path2.curveTo(new Point(310, 50), new Point(400, 150), new Point(200, 300));
                // path2.close();

               // group.append(path, rectPath(path.bbox(), {stroke: {color: "black", width: 1}}));//, path2);
               // surface.draw(group);
            }
        </script>
    </body>
</html>
