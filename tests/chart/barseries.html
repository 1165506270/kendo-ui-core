<!DOCTYPE html>
<html>
    <head>
        <title>kendo.chart</title>
        <script src="../../src/jquery.js"></script>
        <script src="../qunit.js"></script>
        <script src="../qunit-runner.js"></script>
        <link href="../qunit.css" type="text/css" rel="stylesheet"/>
    </head>
    <body>
        <script src="../../src/kendo.core.js"></script>
        <script src="../../src/kendo.chart.js"></script>
        <script type="text/javascript">
            var Chart = kendo.ui.Chart,
                Box = Chart.Box,
                chartBox = new Box(0, 0, 800, 600);

            function BarStub(box) {
                this.box = box;
            }

            BarStub.prototype = {
                updateLayout: function(box) {
                    this.box = box;
                }
            };

            function ViewFactoryStub() {
                this.renderedRects = [];
            }
            ViewFactoryStub.prototype = {
                rect: function(x, y, width, height) {
                    this.renderedRects.push([].slice.call(arguments));
                }
            };

            (function() {
                var series,
                    plotArea,
                    viewFactory,
                    positiveSeries = { data: [1, 2] },
                    negativeSeries = { data: [-1, -2] },
                    VALUE_AXIS_MAX = 2,
                    CATEGORY_AXIS_Y = 2,
                    TOLERANCE = 0.1;

                function PlotAreaStub() { }

                $.extend(PlotAreaStub.prototype, {
                    axisX: {
                        getSlot: function(categoryIndex) {
                            return new Box(categoryIndex, CATEGORY_AXIS_Y,
                            categoryIndex + 1, CATEGORY_AXIS_Y);
                        }
                    },

                    axisY: {
                        getSlot: function(value) {
                            var valueY = VALUE_AXIS_MAX - value,
                                slotTop = Math.min(CATEGORY_AXIS_Y, valueY),
                                slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

                            return new Box(0, slotTop, 0, slotBottom);
                        }
                    }
                });

                function setupBarChart(options) {
                    plotArea = new PlotAreaStub();
                    viewFactory = new ViewFactoryStub();

                    series = new Chart.BarChart(plotArea, options);

                    series.updateLayout();
                }

                module("Bar Chart / Positive Values", {
                    setup: function() {
                        setupBarChart({ series: [ positiveSeries ] });
                    }
                });

                test("Creates bars for series data points", function() {
                    equal(series._bars.length, positiveSeries.data.length);
                });

                test("Reports minimum series value", function() {
                    same(series.getValueRange().min, positiveSeries.data[0]);
                });

                test("Reports maximum series value", function() {
                    same(series.getValueRange().max, positiveSeries.data[1]);
                });

                test("bars are distributed across category axis", function() {
                    var barsX = $.map(series._bars, function(bar) {
                        return bar.box.x1;
                    });

                    same(barsX, [0.3, 1.3], TOLERANCE);
                });

                test("bar bottoms are aligned to category axis", function() {
                    var barsY = $.map(series._bars, function(bar) {
                        return bar.box.y2;
                    });

                    same(barsY, [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
                });

                test("bars have set width", function() {
                    $.each(series._bars, function() {
                        equal(this.box.width(), 0.4, TOLERANCE);
                    });
                });

                test("bars have set height according to value", function() {
                    var barHeights = $.map(series._bars, function(bar) {
                        return bar.box.height();
                    });

                    same(barHeights, [1, 2]);
                });

                module("Bar Chart / Negative Values", {
                    setup: function() {
                        setupBarChart({ series: [ negativeSeries ] });
                    }
                });

                test("Reports minimum series value", function() {
                    same(series.getValueRange().min, negativeSeries.data[1]);
                });

                test("Reports maximum series value", function() {
                    same(series.getValueRange().max, negativeSeries.data[0]);
                });

                test("bar tops are aligned to category axis", function() {
                    var barsY = $.map(series._bars, function(bar) {
                        return bar.box.y1;
                    });

                    same(barsY, [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
                });

                test("bars have set height according to value", function() {
                    var barHeights = $.map(series._bars, function(bar) {
                        return bar.box.height();
                    });

                    same(barHeights, [1, 2]);
                });

                module("Bar Chart / Cluster", {
                    setup: function() {
                        setupBarChart({ series: [ positiveSeries, negativeSeries ] });
                    }
                });

                test("bars in first category are clustered", function() {
                    equal(series._bars[0].box.x2, series._bars[1].box.x1);
                });

                module("Bar Chart / Stack / Positive Values", {
                    setup: function() {
                        setupBarChart({
                            series: [ positiveSeries, positiveSeries ],
                            isStacked: true }
                        );
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(series.getValueRange().min, 2);
                });

                test("reports stacked maximum value", function() {
                    equal(series.getValueRange().max, 4);
                });

                test("bars in first category are stacked", function() {
                    equal(series._bars[1].box.y2, series._bars[0].box.y1);
                });

                test("series have 75% margin", function() {
                    equal(series._bars[0].box.x1, 0.3, TOLERANCE);
                });

                test("bars have set height according to value", function() {
                    var barHeights = $.map(series._bars, function(bar) {
                        return bar.box.height();
                    });

                    same(barHeights, [1, 1, 2, 2]);
                });

                module("Bar Chart / Stack / Negative Values", {
                    setup: function() {
                        setupBarChart({
                            series: [ negativeSeries, negativeSeries ],
                            isStacked: true }
                        );
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(series.getValueRange().min, -4);
                });

                test("reports stacked maximum value", function() {
                    equal(series.getValueRange().max, -2);
                });

                test("bars in first category are stacked", function() {
                    equal(series._bars[1].box.y1, series._bars[0].box.y2);
                });

                test("stack tops are aligned to category axis", function() {
                    same([series._bars[0].box.y1, series._bars[2].box.y1],
                         [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
                });

                test("bars have set height according to value", function() {
                    var barHeights = $.map(series._bars, function(bar) {
                        return bar.box.height();
                    });

                    same(barHeights, [1, 1, 2, 2]);
                });

                module("Bar Chart / Stack / Mixed Values", {
                    setup: function() {
                        setupBarChart({
                            series: [ positiveSeries, negativeSeries ],
                            isStacked: true }
                        );
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(series.getValueRange().min, -2);
                });

                test("reports stacked maximum value", function() {
                    equal(series.getValueRange().max, 2);
                });

                test("bars have set height according to value", function() {
                    var barHeights = $.map(series._bars, function(bar) {
                        return bar.box.height();
                    });

                    same(barHeights, [1, 1, 2, 2]);
                });

            })();

            (function() {
                var series,
                    plotArea,
                    viewFactory,
                    positiveSeries = { data: [1, 2] },
                    negativeSeries = { data: [-1, -2] },
                    CATEGORY_AXIS_X = 2,
                    TOLERANCE = 0.1;

                function PlotAreaStub() { }

                $.extend(PlotAreaStub.prototype, {
                    axisX: {
                        getSlot: function(value) {
                            var valueX = CATEGORY_AXIS_X + value,
                                slotLeft = Math.min(CATEGORY_AXIS_X, valueX),
                                slotRight = Math.max(CATEGORY_AXIS_X, valueX);

                            return new Box(slotLeft, 0, slotRight, 0);
                        }
                    },

                    axisY: {
                        getSlot: function(categoryIndex) {
                            return new Box(CATEGORY_AXIS_X, categoryIndex,
                                           CATEGORY_AXIS_X, categoryIndex + 1);
                        }
                    }
                });

                function setupBarChart(options) {
                    plotArea = new PlotAreaStub();
                    viewFactory = new ViewFactoryStub();

                    series = new Chart.BarChart(plotArea, options);

                    series.updateLayout();
                }

                module("Bar Chart / Horizontal / Positive Values", {
                    setup: function() {
                        setupBarChart({ isVertical: false, series: [ positiveSeries ] });
                    }
                });

                test("bars are distributed across category axis", function() {
                    var barsY = $.map(series._bars, function(bar) {
                        return bar.box.y1;
                    });

                    same(barsY, [0.3, 1.3], TOLERANCE);
                });

                test("bar sides are aligned to category axis", function() {
                    var barsX = $.map(series._bars, function(bar) {
                        return bar.box.x1;
                    });

                    same(barsX, [CATEGORY_AXIS_X, CATEGORY_AXIS_X]);
                });

                test("bars have set height", function() {
                    $.each(series._bars, function() {
                        equal(this.box.height(), 0.4, TOLERANCE);
                    });
                });

                test("bars have set width according to value", function() {
                    var barWidths = $.map(series._bars, function(bar) {
                        return bar.box.width();
                    });

                    same(barWidths, [1, 2]);
                });

                module("Bar Chart / Horizontal / Negative Values", {
                    setup: function() {
                        setupBarChart({ isVertical: false, series: [ negativeSeries ] });
                    }
                });

                test("Reports minimum series value", function() {
                    same(series.getValueRange().min, negativeSeries.data[1]);
                });

                test("Reports maximum series value", function() {
                    same(series.getValueRange().max, negativeSeries.data[0]);
                });

                test("bar sides are aligned to category axis", function() {
                    var barsX = $.map(series._bars, function(bar) {
                        return bar.box.x2;
                    });

                    same(barsX, [CATEGORY_AXIS_X, CATEGORY_AXIS_X]);
                });

                test("bars have set width according to value", function() {
                    var barWidths = $.map(series._bars, function(bar) {
                        return bar.box.width();
                    });

                    same(barWidths, [1, 2]);
                });

                module("Bar Chart / Horizontal / Cluster", {
                    setup: function() {
                        setupBarChart({ isVertical: false, series: [ positiveSeries, negativeSeries ] });
                    }
                });

                test("bars in first category are clustered", function() {
                    equal(series._bars[0].box.y2, series._bars[1].box.y1);
                });

                module("Bar Chart / Horizontal / Stack / Positive Values", {
                    setup: function() {
                        setupBarChart({
                            isVertical: false,
                            series: [ positiveSeries, positiveSeries ],
                            isStacked: true }
                        );
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(series.getValueRange().min, 2);
                });

                test("reports stacked maximum value", function() {
                    equal(series.getValueRange().max, 4);
                });

                test("bars in first category are stacked", function() {
                    equal(series._bars[1].box.x1, series._bars[0].box.x2);
                });

                test("bars have set width according to value", function() {
                    var barWidths = $.map(series._bars, function(bar) {
                        return bar.box.width();
                    });

                    same(barWidths, [1, 1, 2, 2]);
                });

                test("series have 75% margin", function() {
                    equal(series._bars[0].box.y1, 0.3, TOLERANCE);
                });

                module("Bar Chart / Horizontal / Stack / Negative Values", {
                    setup: function() {
                        setupBarChart({
                            isVertical: false,
                            series: [ negativeSeries, negativeSeries ],
                            isStacked: true }
                        );
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(series.getValueRange().min, -4);
                });

                test("reports stacked maximum value", function() {
                    equal(series.getValueRange().max, -2);
                });

                test("bars in first category are stacked", function() {
                    equal(series._bars[1].box.x2, series._bars[0].box.x1);
                });

                test("stack sides are aligned to category axis", function() {
                    same([series._bars[0].box.x2, series._bars[2].box.x2],
                         [CATEGORY_AXIS_X, CATEGORY_AXIS_X]);
                });

                test("bars have set width according to value", function() {
                    var barWidths = $.map(series._bars, function(bar) {
                        return bar.box.width();
                    });

                    same(barWidths, [1, 1, 2, 2]);
                });

                module("Bar Chart / Horizontal / Stack / Mixed Values", {
                    setup: function() {
                        setupBarChart({
                            isVertical: false,
                            series: [ positiveSeries, negativeSeries ],
                            isStacked: true }
                        );
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(series.getValueRange().min, -2);
                });

                test("reports stacked maximum value", function() {
                    equal(series.getValueRange().max, 2);
                });

                test("bars have set width according to value", function() {
                    var barWidths = $.map(series._bars, function(bar) {
                        return bar.box.width();
                    });

                    same(barWidths, [1, 1, 2, 2]);
                });

            })();

            (function() {
                var cluster,
                    bars,
                    clusterBox = new Box(0, 0, 350, 350),
                    barBox = new Box(1, 1, 1, 1);

                function createCluster(options) {
                    cluster = new Chart.ClusterLayout(options);
                    bars = [ new BarStub(barBox), new BarStub(barBox) ];
                    [].push.apply(cluster.children, bars);
                    cluster.updateLayout(clusterBox);
                }

                module("Cluster Layout / Horizontal", {
                    setup: function() {
                        createCluster({ gap: 0 });
                    }
                });

                test("distributes width evenly", function() {
                    $.each(bars, function() {
                        equal(this.box.width(), clusterBox.width() / bars.length)
                    });
                });

                test("positions children next to each other", function() {
                    $.each(bars, function(index) {
                        equal(this.box.x1, this.box.width() * index)
                    });
                });

                test("leaves 75% gap on both sides", function() {
                    createCluster(/* Default gap size */);

                    equal(bars[0].box.x1, 75);
                    equal(bars[1].box.x2, 275);
                });

                module("Cluster Layout / Vertical", {
                    setup: function() {
                        createCluster({ isVertical: true, gap: 0 });
                    }
                });

                test("distributes height evenly", function() {
                    $.each(bars, function() {
                        equal(this.box.height(), clusterBox.height() / bars.length)
                    });
                });

                test("positions children below each other", function() {
                    $.each(bars, function(index) {
                        equal(this.box.y1, this.box.height() * index)
                    });
                });
            })();

            (function() {
                var stack,
                    stackBox = new Box(50, 50, 100, 100);

                module("Stack Layout / Vertical", {
                    setup: function() {
                        stack = new Chart.StackLayout();

                        stack.children.push(
                            new BarStub(new Box(0, 90, 100, 100)),
                            new BarStub(new Box(0, 80, 100, 100)),
                            new BarStub(new Box(0, 70, 100, 100))
                        );

                        stack.updateLayout(stackBox);
                    }
                });

                test("first bar remains at its position", function() {
                    equal(stack.children[0].box.y1, 90);
                });

                test("first bar height is not changed", function() {
                    equal(stack.children[0].box.height(), 10);
                });

                test("second bar is placed on top of the first", function() {
                    equal(stack.children[1].box.y2, stack.children[0].box.y1);
                });

                test("second bar height is not changed", function() {
                    equal(stack.children[1].box.height(), 20);
                });

                test("third bar is placed on top of the second", function() {
                    equal(stack.children[2].box.y2, stack.children[1].box.y1);
                });

                test("third bar height is not changed", function() {
                    equal(stack.children[2].box.height(), 30);
                });

                test("reports final box after layout", function() {
                    same([stack.box.x1, stack.box.y1, stack.box.x2, stack.box.y2],
                         [50, 40, 100, 100]);
                });

                test("updates children width to fit box", function() {
                    equal(stack.children[0].box.width(), stackBox.width());
                    equal(stack.children[1].box.width(), stackBox.width());
                });

                test("updates children X position to match targetBox", function() {
                    equal(stack.children[0].box.x1, stackBox.x1);
                    equal(stack.children[1].box.x1, stackBox.x1);
                });

                module("Stack Layout / Vertical / Reversed", {
                    setup: function() {
                        stack = new Chart.StackLayout({ isReversed: true });

                        stack.children.push(
                            new BarStub(new Box(0, 90, 100, 100)),
                            new BarStub(new Box(0, 80, 100, 100)),
                            new BarStub(new Box(0, 70, 100, 100))
                        );

                        stack.updateLayout(stackBox);
                    }
                });

                test("first bar remains at its position", function() {
                    equal(stack.children[0].box.y1, 90);
                });

                test("first bar height is not changed", function() {
                    equal(stack.children[0].box.height(), 10);
                });

                test("second bar is placed below the first", function() {
                    equal(stack.children[1].box.y1, stack.children[0].box.y2);
                });

                test("second bar height is not changed", function() {
                    equal(stack.children[1].box.height(), 20);
                });

                test("third bar is placed below the second", function() {
                    equal(stack.children[2].box.y1, stack.children[1].box.y2);
                });

                test("third bar height is not changed", function() {
                    equal(stack.children[2].box.height(), 30);
                });

                test("reports final box after layout", function() {
                    same([stack.box.x1, stack.box.y1, stack.box.x2, stack.box.y2],
                         [50, 90, 100, 150]);
                });

                test("updates children width to fit box", function() {
                    equal(stack.children[0].box.width(), stackBox.width());
                    equal(stack.children[1].box.width(), stackBox.width());
                });

                test("updates children X position to match targetBox", function() {
                    equal(stack.children[0].box.x1, stackBox.x1);
                    equal(stack.children[1].box.x1, stackBox.x1);
                });

                module("Stack Layout / Horizontal", {
                    setup: function() {
                        stack = new Chart.StackLayout({ isVertical: false });
                        stack.children.push(
                            new BarStub(new Box(0, 0, 20, 10)),
                            new BarStub(new Box(0, 0, 30, 10)),
                            new BarStub(new Box(0, 0, 40, 10))
                        );

                        stack.updateLayout(stackBox);
                    }
                });

                test("first bar remains at its position", function() {
                    equal(stack.children[0].box.x1, 0);
                });

                test("first bar width is not changed", function() {
                    equal(stack.children[0].box.width(), 20);
                });

                test("second bar is placed to the right of the first", function() {
                    equal(stack.children[1].box.x1, stack.children[0].box.x2);
                });

                test("second bar width is not changed", function() {
                    equal(stack.children[1].box.width(), 30);
                });

                test("third bar is placed to the right of the second", function() {
                    equal(stack.children[2].box.x1, stack.children[1].box.x2);
                });

                test("third bar width is not changed", function() {
                    equal(stack.children[2].box.width(), 40);
                });

                test("reports final box after layout", function() {
                    same([stack.box.x1, stack.box.y1, stack.box.x2, stack.box.y2],
                         [0, 50, 90, 100]);
                });

                test("updates children height to fit box", function() {
                    equal(stack.children[0].box.height(), stackBox.height());
                    equal(stack.children[1].box.height(), stackBox.height());
                });

                test("updates children Y position to match targetBox", function() {
                    equal(stack.children[0].box.y1, stackBox.y1);
                    equal(stack.children[1].box.y1, stackBox.y1);
                });

                module("Stack Layout / Horizontal / Reversed", {
                    setup: function() {
                        stack = new Chart.StackLayout({ isVertical: false, isReversed: true });
                        stack.children.push(
                            new BarStub(new Box(100, 0, 120, 10)),
                            new BarStub(new Box(100, 0, 130, 10)),
                            new BarStub(new Box(100, 0, 140, 10))
                        );

                        stack.updateLayout(stackBox);
                    }
                });

                test("first bar remains at its position", function() {
                    equal(stack.children[0].box.x1, 100);
                });

                test("first bar width is not changed", function() {
                    equal(stack.children[0].box.width(), 20);
                });

                test("second bar is placed to the left of the first", function() {
                    equal(stack.children[1].box.x2, stack.children[0].box.x1);
                });

                test("second bar width is not changed", function() {
                    equal(stack.children[1].box.width(), 30);
                });

                test("third bar is placed to the left of the second", function() {
                    equal(stack.children[2].box.x2, stack.children[1].box.x1);
                });

                test("third bar width is not changed", function() {
                    equal(stack.children[2].box.width(), 40);
                });

                test("reports final box after layout", function() {
                    same([stack.box.x1, stack.box.y1, stack.box.x2, stack.box.y2],
                         [30, 50, 120, 100]);
                });

                test("updates children height to fit box", function() {
                    equal(stack.children[0].box.height(), stackBox.height());
                    equal(stack.children[1].box.height(), stackBox.height());
                });

                test("updates children Y position to match targetBox", function() {
                    equal(stack.children[0].box.y1, stackBox.y1);
                    equal(stack.children[1].box.y1, stackBox.y1);
                });

            })();

        </script>

        <h1 id="qunit-header">kendo.chart</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <div id="qunit-fixture">test markup, will be hidden</div>
        <ul id="log"></ul>

    </body>
</html>
