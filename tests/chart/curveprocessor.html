<!DOCTYPE html>
<html>
    <head>
        <title>CurveProcessor</title>
        <script src="../jquery-loader.js"></script>
        <script src="../qunit/qunit/qunit.js"></script>
        <script src="../qunit/addons/close-enough/qunit-close-enough.js"></script>
        <script src="../kendo-test-helpers.js"></script>
        <link href="../qunit/qunit/qunit.css" type="text/css" rel="stylesheet"/>
    </head>
    <body>
        <script src="../../src/kendo.core.js"></script>
        <script src="../../src/kendo.data.js"></script>
        <script src="../../src/kendo.dataviz.core.js"></script>
        
        <script src="util.js"></script>
        <script type="text/javascript">
         (function() {
            var kendo = window.kendo,                       
                dataviz = kendo.dataviz,
                Point = dataviz.Point2D,
                CurveProcessor = dataviz.CurveProcessor,
                processor = new CurveProcessor(0,false);
                               
            module("curveprocessor / monotonic", {
            });
            
            test("ascending points are correctly detected", function() {
                var p0 = new Point(1,2),
                    p1 = new Point(1.1, 3),
                    p2 = new Point(4, 3.1),
                    monotonicByX = processor.isMonotonicByField(p0,p1,p2, "x"),
                    monotonicByY = processor.isMonotonicByField(p0,p1,p2, "y");                        
                ok(monotonicByX && monotonicByY);
            }); 

            test("descending points are correctly detected", function() {
                var p0 = new Point(4, 3),
                    p1 = new Point(1.1, 2),
                    p2 = new Point(1, 1.99),
                    monotonicByX = processor.isMonotonicByField(p0,p1,p2, "x"),
                    monotonicByY = processor.isMonotonicByField(p0,p1,p2, "y");                        
                ok(monotonicByX && monotonicByY);
            });  

            test("points with equal values are not monotonic", function() {
                var p0 = new Point(4, 3),
                    p1 = new Point(4, 2),
                    p2 = new Point(1, 2),
                    monotonicByX = processor.isMonotonicByField(p0,p1,p2, "x"),
                    monotonicByY = processor.isMonotonicByField(p0,p1,p2, "y");                        
                ok(!(monotonicByX || monotonicByY));
            });            
            
            module("curveprocessor / orientation", {
            });
             
            test("the axes are not inverted for ascending by X points", function() {
                var p0 = new Point(1,2),
                    p1 = new Point(1.1, 3),
                    p2 = new Point(4, 3),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "x" && result.yField == "y");
            }); 

            test("the axes are not inverted for descending by X points", function() {
                var p0 = new Point(4,2),
                    p1 = new Point(1.1, 3),
                    p2 = new Point(1, 3),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "x" && result.yField == "y");
            });

            test("the axes are inverted for descending by y points when the third point is below the line determined by the first two", function() {
                var p0 = new Point(4, 3),
                    p1 = new Point(6, 2),
                    p2 = new Point(4, 1),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "y" && result.yField == "x");
            });

            test("the axes are inverted for ascending by y points when the third point is above the line determined by the first two", function() {
                var p0 = new Point(4, 2),
                    p1 = new Point(6, 3),
                    p2 = new Point(4, 4),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "y" && result.yField == "x");
            });        

            test("the axes are not inverted when the third point is below the line determined by the first two", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(2.5, 2),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "x" && result.yField == "y");
            }); 

            test("the axes are not inverted when the third point is above the line determined by the first two", function() {
                var p0 = new Point(3, 3),
                    p1 = new Point(1, 1),
                    p2 = new Point(1.5, 2),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "x" && result.yField == "y");
            });            
            
            test("the axes are inverted for descending by y points when the first two points have equal x value", function() {
                var p0 = new Point(2, 5),
                    p1 = new Point(2, 4),
                    p2 = new Point(4, 3),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "y" && result.yField == "x");
            });
            

            test("the axes are inverted for ascending by y points when the first two points have equal x value", function() {
                var p0 = new Point(2, 2),
                    p1 = new Point(2, 3),
                    p2 = new Point(4, 4),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "y" && result.yField == "x");
            }); 
            
            test("the axes are not inverted when the points are on the same line", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(4, 4),
                    result = processor.getOrientation(p0,p1,p2);                
                ok(result.xField == "x" && result.yField == "y");
            });

            module("curveprocessor / isLine", {
            });   
                
            test("monotonic points on the same line are detected", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(4, 4),
                    result = processor.isLine(p0,p1,p2);                
                ok(result);
            });

            test("points on the same line are detected when the third point is before the second point", function() {
                var p0 = new Point(2, 2),
                    p1 = new Point(4, 4),
                    p2 = new Point(1, 1),
                    result = processor.isLine(p0,p1,p2);                
                ok(result);
            });    
            
            test("points on the same line are detected for a vertical line", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(1, 4),
                    p2 = new Point(1, 1),
                    result = processor.isLine(p0,p1,p2);                
                ok(result);
            });
                       
            test("points on the same line are detected for a vertical line when the third point is before the second point", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(1, 1),
                    p2 = new Point(1, 4),
                    result = processor.isLine(p0,p1,p2);                
                ok(result);
            });
            
            module("curveprocessor / tangent", {
            });

            test("tangent is correctly calculated", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(3, 4),
                    result = processor.getTangent(p0,p1, "x", "y");                
                equal(result, -1 / 2);
            });

            test("tangent is correctly calculated for inverted axes", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(3, 4),
                    result = processor.getTangent(p0,p1, "y", "x");                
                equal(result, -2);
            });             

            test("tangent is 0 for equal by x points", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(1, 4),
                    result = processor.getTangent(p0,p1, "x", "y");                
                equal(result, 0);
            }); 

            module("curveprocessor / control points / calculation", {
            }); 

            test("first control point is correctly calculated", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(2, 4),
                    tangent = 1.5,
                    expectedX = 1.333,
                    expectedY = 3.5,
                    result = processor.getFirstControlPoint(tangent, p0,p1, "x", "y");                
                equal(result.x.toFixed(3), expectedX, "correct X");
                equal(result.y.toFixed(3), expectedY, "correct Y");
            });

            test("first control point is correctly calculated for inverted axes", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(4, 2),
                    tangent = 1.5,
                    expectedY = 1.333,
                    expectedX = 3.5,
                    result = processor.getFirstControlPoint(tangent, p0,p1, "y", "x");                
                equal(result.x.toFixed(3), expectedX, "correct X");
                equal(result.y.toFixed(3), expectedY, "correct Y");
            }); 

            test("second control point is correctly calculated", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(2, 5),
                    tangent = 1.5,
                    expectedX = 1.667,
                    expectedY = 4.5,
                    result = processor.getSecondControlPoint(tangent, p0,p1, "x", "y");                
                equal(result.x.toFixed(3), expectedX, "correct X");
                equal(result.y.toFixed(3), expectedY, "correct Y");
            });   

            test("second control point is correctly calculated for inverted axes", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(5, 2),
                    tangent = 1.5,
                    expectedY = 1.667,
                    expectedX = 4.5,
                    result = processor.getSecondControlPoint(tangent, p0,p1, "y", "x");                
                equal(result.x.toFixed(3), expectedX, "correct X");
                equal(result.y.toFixed(3), expectedY, "correct Y");
            }); 

            module("curveprocessor / control points / restrict", {
            }); 
            
            test("first control point is restricted for ascending by y points when its y value is bigger than the y value of the last point", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(1.1, 3),
                    p2 = new Point(3, 3.1),
                    tangent = 1.05,
                    expectedY = 3.1,
                    expectedX = 1.195,
                    controlPoint = processor.getFirstControlPoint(tangent, p1, p2, "x", "y"); 
                    
                processor.restrictControlPoint(p1,p2, controlPoint, tangent)
                equal(controlPoint.x.toFixed(3), expectedX, "correct X");
                equal(controlPoint.y.toFixed(3), expectedY, "correct Y");
            });   

            test("first control point is restricted for ascending by y descending by x points when its y value is bigger than the y value of the last point", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(2.9, 3),
                    p2 = new Point(1, 3.1),
                    tangent = -1.05,
                    expectedY = 3.1,
                    expectedX = 2.805,
                    controlPoint = processor.getFirstControlPoint(tangent, p1, p2, "x", "y"); 
                    
                processor.restrictControlPoint(p1,p2, controlPoint, tangent)
                equal(controlPoint.x.toFixed(3), expectedX, "correct X");
                equal(controlPoint.y.toFixed(3), expectedY, "correct Y");
            });

            test("second control point is restricted for ascending by y points when its y value is smaller than the y value of the first point", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 1.1),
                    p2 = new Point(3.1, 3),
                    tangent = 0.9523809523809523,
                    expectedY = 1,
                    expectedX = 2.895,
                    controlPoint = processor.getSecondControlPoint(tangent, p0, p1, "x", "y"); 
                    
                processor.restrictControlPoint(p0,p1, controlPoint, tangent)
                equal(controlPoint.x.toFixed(3), expectedX, "correct X");
                equal(controlPoint.y.toFixed(3), expectedY, "correct Y");
            });
            
            test("second control point is restricted for ascending by y descending by x points when its y value is smaller than the y value of the first point", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(1, 1.1),
                    p2 = new Point(0.9, 3),
                    tangent = -0.9523809523809523,
                    expectedY = 1,
                    expectedX = 1.105,
                    controlPoint = processor.getSecondControlPoint(tangent, p0, p1, "x", "y"); 
                    
                processor.restrictControlPoint(p0,p1, controlPoint, tangent)
                equal(controlPoint.x.toFixed(3), expectedX, "correct X");
                equal(controlPoint.y.toFixed(3), expectedY, "correct Y");
            }); 

            test("first control point is restricted for descending by y points when its y value is smaller than the y value of the last point", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(1.1, 1),
                    p2 = new Point(3, 0.9),
                    tangent = -1.05,
                    expectedY = 0.9,
                    expectedX = 1.195,
                    controlPoint = processor.getFirstControlPoint(tangent, p1, p2, "x", "y"); 
                    
                processor.restrictControlPoint(p1,p2, controlPoint, tangent)
                equal(controlPoint.x.toFixed(3), expectedX, "correct X");
                equal(controlPoint.y.toFixed(3), expectedY, "correct Y");
            });

            test("first control point is restricted for descending by y descending by x points when its y value is smaller than the y value of the last point", function() {
                var p0 = new Point(3, 3),
                    p1 = new Point(2.9, 1),
                    p2 = new Point(1, 0.9),
                    tangent = 1.05,
                    expectedY = 0.9,
                    expectedX = 2.805,
                    controlPoint = processor.getFirstControlPoint(tangent, p1, p2, "x", "y"); 
                    
                processor.restrictControlPoint(p1,p2, controlPoint, tangent)
                equal(controlPoint.x.toFixed(3), expectedX, "correct X");
                equal(controlPoint.y.toFixed(3), expectedY, "correct Y");
            }); 

            test("second control point is restricted for descending by y points when its y value is bigger than the y value of the first point", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(3, 2.9),
                    p2 = new Point(3.1, 1),
                    tangent = -0.9523809523809523,
                    expectedY = 3,
                    expectedX = 2.895,
                    controlPoint = processor.getSecondControlPoint(tangent, p0, p1, "x", "y"); 
                    
                processor.restrictControlPoint(p0,p1, controlPoint, tangent)
                equal(controlPoint.x.toFixed(3), expectedX, "correct X");
                equal(controlPoint.y.toFixed(3), expectedY, "correct Y");
            });

            test("second control point is restricted for descending by y descending by xpoints when its y value is bigger than the y value of the first point", function() {
                var p0 = new Point(3, 3),
                    p1 = new Point(1, 2.9),
                    p2 = new Point(0.9, 1),
                    tangent = 0.9523809523809523,
                    expectedY = 3,
                    expectedX = 1.105,
                    controlPoint = processor.getSecondControlPoint(tangent, p0, p1, "x", "y"); 
                    
                processor.restrictControlPoint(p0,p1, controlPoint, tangent)
                equal(controlPoint.x.toFixed(3), expectedX, "correct X");
                equal(controlPoint.y.toFixed(3), expectedY, "correct Y");
            });            
            
        })();
        </script>

        <h1 id="qunit-header">CurveProcessor</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <div id="qunit-fixture">test markup, will be hidden</div>
        <ul id="log"></ul>

        <div id="container">
        </div>
    </body>             