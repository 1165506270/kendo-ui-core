<!DOCTYPE html>
<html>
    <head>
        <title>CurveProcessor</title>
        <script src="../jquery-loader.js"></script>
        <script src="../qunit/qunit/qunit.js"></script>
        <script src="../qunit/addons/close-enough/qunit-close-enough.js"></script>
        <script src="../kendo-test-helpers.js"></script>
        <link href="../qunit/qunit/qunit.css" type="text/css" rel="stylesheet"/>
    </head>
    <body>
        <script src="../../src/kendo.core.js"></script>
        <script src="../../src/kendo.data.js"></script>
        <script src="../../src/kendo.dataviz.core.js"></script>

        <script src="util.js"></script>
        <script type="text/javascript">
         (function() {
            var kendo = window.kendo,
                dataviz = kendo.dataviz,
                Point = dataviz.Point2D,
                CurveProcessor = dataviz.CurveProcessor,
                EXTREMUM_ALLOWED_ERROR = 0.01;
                processor = new CurveProcessor(EXTREMUM_ALLOWED_ERROR,false),
                COORD_PRECISION = 3,
                round = kendo.dataviz.round;

            module("curveprocessor / monotonic", {
            });

            test("ascending points are correctly detected", function() {
                var p0 = new Point(1,2),
                    p1 = new Point(1.1, 3),
                    p2 = new Point(4, 3.1),
                    monotonicByX = processor.isMonotonicByField(p0,p1,p2, "x"),
                    monotonicByY = processor.isMonotonicByField(p0,p1,p2, "y");
                ok(monotonicByX && monotonicByY);
            });

            test("descending points are correctly detected", function() {
                var p0 = new Point(4, 3),
                    p1 = new Point(1.1, 2),
                    p2 = new Point(1, 1.99),
                    monotonicByX = processor.isMonotonicByField(p0,p1,p2, "x"),
                    monotonicByY = processor.isMonotonicByField(p0,p1,p2, "y");
                ok(monotonicByX && monotonicByY);
            });

            test("points with equal values are not monotonic", function() {
                var p0 = new Point(4, 3),
                    p1 = new Point(4, 2),
                    p2 = new Point(1, 2),
                    monotonicByX = processor.isMonotonicByField(p0,p1,p2, "x"),
                    monotonicByY = processor.isMonotonicByField(p0,p1,p2, "y");
                ok(!(monotonicByX || monotonicByY));
            });

            module("curveprocessor / orientation", {
            });

            test("the axes are not inverted for ascending by X points", function() {
                var p0 = new Point(1,2),
                    p1 = new Point(1.1, 3),
                    p2 = new Point(4, 3),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "x" && result.yField == "y");
            });

            test("the axes are not inverted for descending by X points", function() {
                var p0 = new Point(4,2),
                    p1 = new Point(1.1, 3),
                    p2 = new Point(1, 3),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "x" && result.yField == "y");
            });

            test("the axes are inverted for descending by y points when the third point is below the line determined by the first two", function() {
                var p0 = new Point(4, 3),
                    p1 = new Point(6, 2),
                    p2 = new Point(4, 1),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "y" && result.yField == "x");
            });

            test("the axes are inverted for ascending by y points when the third point is above the line determined by the first two", function() {
                var p0 = new Point(4, 2),
                    p1 = new Point(6, 3),
                    p2 = new Point(4, 4),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "y" && result.yField == "x");
            });

            test("the axes are not inverted when the third point is below the line determined by the first two", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(2.5, 2),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "x" && result.yField == "y");
            });

            test("the axes are not inverted when the third point is above the line determined by the first two", function() {
                var p0 = new Point(3, 3),
                    p1 = new Point(1, 1),
                    p2 = new Point(1.5, 2),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "x" && result.yField == "y");
            });

            test("the axes are inverted for descending by y points when the first two points have equal x value", function() {
                var p0 = new Point(2, 5),
                    p1 = new Point(2, 4),
                    p2 = new Point(4, 3),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "y" && result.yField == "x");
            });


            test("the axes are inverted for ascending by y points when the first two points have equal x value", function() {
                var p0 = new Point(2, 2),
                    p1 = new Point(2, 3),
                    p2 = new Point(4, 4),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "y" && result.yField == "x");
            });

            test("the axes are not inverted when the points are on the same line", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(4, 4),
                    result = processor.getOrientation(p0,p1,p2);
                ok(result.xField == "x" && result.yField == "y");
            });

            module("curveprocessor / isLine", {
            });

            test("monotonic points on the same line are detected", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(4, 4),
                    result = processor.isLine(p0,p1,p2);
                ok(result);
            });

            test("points on the same line are detected when the third point is before the second point", function() {
                var p0 = new Point(2, 2),
                    p1 = new Point(4, 4),
                    p2 = new Point(1, 1),
                    result = processor.isLine(p0,p1,p2);
                ok(result);
            });

            test("points on the same line are detected for a vertical line", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(1, 4),
                    p2 = new Point(1, 1),
                    result = processor.isLine(p0,p1,p2);
                ok(result);
            });

            test("points on the same line are detected for a vertical line when the third point is before the second point", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(1, 1),
                    p2 = new Point(1, 4),
                    result = processor.isLine(p0,p1,p2);
                ok(result);
            });

            module("curveprocessor / tangent", {
            });

            test("tangent is correctly calculated", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(3, 4),
                    result = processor.getTangent(p0,p1, "x", "y");
                equal(result, -1 / 2);
            });

            test("tangent is correctly calculated for inverted axes", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(3, 4),
                    result = processor.getTangent(p0,p1, "y", "x");
                equal(result, -2);
            });

            test("tangent is 0 for equal by x points", function() {
                var p0 = new Point(1, 5),
                    p1 = new Point(1, 4),
                    result = processor.getTangent(p0,p1, "x", "y");
                equal(result, 0);
            });

            module("curveprocessor / control points / calculation", {
            });

            test("first control point is correctly calculated", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(2, 4),
                    tangent = 1.5,
                    expectedX = 1.333,
                    expectedY = 3.5,
                    controlPoint = processor.getFirstControlPoint(tangent, p0,p1, "x", "y");
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("first control point is correctly calculated for inverted axes", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(4, 2),
                    tangent = 1.5,
                    expectedY = 1.333,
                    expectedX = 3.5,
                    controlPoint = processor.getFirstControlPoint(tangent, p0,p1, "y", "x");
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("second control point is correctly calculated", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(2, 5),
                    tangent = 1.5,
                    expectedX = 1.667,
                    expectedY = 4.501,
                    controlPoint = processor.getSecondControlPoint(tangent, p0,p1, "x", "y");
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("second control point is correctly calculated for inverted axes", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(5, 2),
                    tangent = 1.5,
                    expectedY = 1.667,
                    expectedX = 4.501,
                    controlPoint = processor.getSecondControlPoint(tangent, p0,p1, "y", "x");
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            module("curveprocessor / control points / restrict", {
            });

            test("first control point is restricted for ascending by y points when its y value is bigger than the y value of the last point", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(1.1, 3),
                    p2 = new Point(3, 3.1),
                    tangent = 1.05,
                    expectedY = 3.1,
                    expectedX = 1.195,
                    controlPoint = processor.getFirstControlPoint(tangent, p1, p2, "x", "y");

                processor.restrictControlPoint(p1,p2, controlPoint, tangent)
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("first control point is restricted for ascending by y descending by x points when its y value is bigger than the y value of the last point", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(2.9, 3),
                    p2 = new Point(1, 3.1),
                    tangent = -1.05,
                    expectedY = 3.1,
                    expectedX = 2.805,
                    controlPoint = processor.getFirstControlPoint(tangent, p1, p2, "x", "y");

                processor.restrictControlPoint(p1,p2, controlPoint, tangent)
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("second control point is restricted for ascending by y points when its y value is smaller than the y value of the first point", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 1.1),
                    p2 = new Point(3.1, 3),
                    tangent = 0.9523809523809523,
                    expectedY = 1,
                    expectedX = 2.895,
                    controlPoint = processor.getSecondControlPoint(tangent, p0, p1, "x", "y");

                processor.restrictControlPoint(p0,p1, controlPoint, tangent)
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("second control point is restricted for ascending by y descending by x points when its y value is smaller than the y value of the first point", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(1, 1.1),
                    p2 = new Point(0.9, 3),
                    tangent = -0.9523809523809523,
                    expectedY = 1,
                    expectedX = 1.105,
                    controlPoint = processor.getSecondControlPoint(tangent, p0, p1, "x", "y");

                processor.restrictControlPoint(p0,p1, controlPoint, tangent)
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("first control point is restricted for descending by y points when its y value is smaller than the y value of the last point", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(1.1, 1),
                    p2 = new Point(3, 0.9),
                    tangent = -1.05,
                    expectedY = 0.9,
                    expectedX = 1.195,
                    controlPoint = processor.getFirstControlPoint(tangent, p1, p2, "x", "y");

                processor.restrictControlPoint(p1,p2, controlPoint, tangent)
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("first control point is restricted for descending by y descending by x points when its y value is smaller than the y value of the last point", function() {
                var p0 = new Point(3, 3),
                    p1 = new Point(2.9, 1),
                    p2 = new Point(1, 0.9),
                    tangent = 1.05,
                    expectedY = 0.9,
                    expectedX = 2.805,
                    controlPoint = processor.getFirstControlPoint(tangent, p1, p2, "x", "y");

                processor.restrictControlPoint(p1,p2, controlPoint, tangent)
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("second control point is restricted for descending by y points when its y value is bigger than the y value of the first point", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(3, 2.9),
                    p2 = new Point(3.1, 1),
                    tangent = -0.9523809523809523,
                    expectedY = 3,
                    expectedX = 2.895,
                    controlPoint = processor.getSecondControlPoint(tangent, p0, p1, "x", "y");

                processor.restrictControlPoint(p0,p1, controlPoint, tangent)
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            test("second control point is restricted for descending by y descending by xpoints when its y value is bigger than the y value of the first point", function() {
                var p0 = new Point(3, 3),
                    p1 = new Point(1, 2.9),
                    p2 = new Point(0.9, 1),
                    tangent = 0.9523809523809523,
                    expectedY = 3,
                    expectedX = 1.105,
                    controlPoint = processor.getSecondControlPoint(tangent, p0, p1, "x", "y");

                processor.restrictControlPoint(p0,p1, controlPoint, tangent)
                equal(round(controlPoint.x, COORD_PRECISION), expectedX, "correct X");
                equal(round(controlPoint.y, COORD_PRECISION), expectedY, "correct Y");
            });

            module("curveprocessor / control points / line", {
            });

            test("control points lie on the the data points line", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(2, 2),
                    p2 = new Point(3, 3),
                    cp1 = Point(1.667, 1.667),
                    cp2 = Point(2.333,2.333),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(controlPoints[0].x, cp1.x, "correct second control point X");
                equal(controlPoints[0].y, cp1.y, "correct second control point Y");
                equal(controlPoints[1].x, cp2.x, "correct first control point X");
                equal(controlPoints[1].y, cp2.y, "correct first control point Y");
            });

            test("control points lie on the the data points line for vertical line", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(1, 2),
                    p2 = new Point(1, 3),
                    cp1 = Point(1, 2),
                    cp2 = Point(1, 2),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(controlPoints[0].x, cp1.x, "correct second control point X");
                equal(controlPoints[0].y, cp1.y, "correct second control point Y");
                equal(controlPoints[1].x, cp2.x, "correct first control point X");
                equal(controlPoints[1].y, cp2.y, "correct first control point Y");
            });

            module("curveprocessor / control points / monotonic", {
            });

            test("control points lie on the line parallel to the end data points line", function() {
                var p0 = new Point(3, 4),
                    p1 = new Point(5, 6),
                    p2 = new Point(7, 9),
                    cp1 = Point(4.334, 5.1675),
                    cp2 = Point(5.666, 6.8325),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("control points lie on the line parallel to the end data points line and are restricted when their y value exceeds the end data points y value", function() {
                var p0 = new Point(3, 3),
                    p1 = new Point(1, 2.9),
                    p2 = new Point(0.9, 1),
                    cp1 = Point(1.105, 3),
                    cp2 = Point(0.9667,  2.8682857142857143),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            module("curveprocessor / control points / extremum", {
            });

            test("control points preserve a high extremum in the middle point for ascending by x points", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(4, 1),
                    cp1 = Point(2.334, 3),
                    cp2 = Point(3.333, 3),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("control points preserve a low extremum in the middle point for ascending by x points", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(3, 1),
                    p2 = new Point(4, 3),
                    cp1 = Point(2.334, 1),
                    cp2 = Point(3.333, 1),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("control points preserve a high extremum in the middle point for descending by x points", function() {
                var p0 = new Point(4, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(1, 1),
                    cp1 = Point(3.333, 3),
                    cp2 = Point(2.334, 3),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("control points preserve a low extremum in the middle point for descending by x points", function() {
                var p0 = new Point(4, 3),
                    p1 = new Point(3, 1),
                    p2 = new Point(1, 3),
                    cp1 = Point(3.333, 1),
                    cp2 = Point(2.334, 1),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("control points preserve a high extremum in the middle point for descending by y points", function() {
                var p0 = new Point(1, 4),
                    p1 = new Point(3, 3),
                    p2 = new Point(1, 1),
                    cp1 = Point(3, 3.333),
                    cp2 = Point(3, 2.334),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "y", yField: "x"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("control points preserve a low extremum in the middle point for descending by y points", function() {
                var p0 = new Point(3, 4),
                    p1 = new Point(1, 3),
                    p2 = new Point(3, 1),
                    cp1 = Point(1, 3.333),
                    cp2 = Point(1, 2.334),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "y", yField: "x"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("control points preserve a high extremum in the middle point for ascending by y points", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 3),
                    p2 = new Point(1, 4),
                    cp1 = Point(3, 2.334),
                    cp2 = Point(3, 3.333),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "y", yField: "x"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("control points preserve a low extremum in the middle point for ascending by y points", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(1, 3),
                    p2 = new Point(3, 4),
                    cp1 = Point(1, 2.334),
                    cp2 = Point(1, 3.333),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "y", yField: "x"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            module("curveprocessor / control points / reverse axis", {
            });

            test("tangent is equal to the allowed error when the first point y value is lower or equal than the second point and bigger than the third", function() {
                var p0 = new Point(1, 1),
                    p1 = new Point(3, 1),
                    p2 = new Point(2, 2),
                    cp1 = Point(2.334, 0.99334),
                    cp2 = Point(3.00333, 1.333),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("tangent is equal to the negative allowed error when the first point y value is lower or equal than the second point and bigger than the third", function() {
                var p0 = new Point(3, 1),
                    p1 = new Point(1, 1),
                    p2 = new Point(2, 2),
                    cp1 = Point(1.666, 0.99334),
                    cp2 = Point(0.99667, 1.333),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("tangent is equal to the negative allowed error when the first point y value is bigger or equal than the second point and lower than the third", function() {
                var p0 = new Point(1, 3),
                    p1 = new Point(3, 3),
                    p2 = new Point(2, 2),
                    cp1 = Point(2.334, 3.00666),
                    cp2 = Point(3.00333, 2.667),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("tangent is equal to the allowed error when the first point y value is bigger or equal than the second point and lower than the third", function() {
                var p0 = new Point(3, 3),
                    p1 = new Point(1, 3),
                    p2 = new Point(2, 2),
                    cp1 = Point(1.666, 3.00666),
                    cp2 = Point(0.99667, 2.667),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "x", yField: "y"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });

            test("tangent is equal to the allowed error when the first point x value is bigger or equal than the second point and lower than the third", function() {
                var p0 = new Point(2, 1),
                    p1 = new Point(2, 3),
                    p2 = new Point(3, 2),
                    cp1 = Point(1.99334, 2.334),
                    cp2 = Point(2.333, 3.00333),
                    controlPoints = processor.getMiddleControlPoints(p0, p1, p2, {xField: "y", yField: "x"});

                equal(round(controlPoints[0].x, COORD_PRECISION), cp1.x, "correct second control point X");
                equal(round(controlPoints[0].y, COORD_PRECISION), cp1.y, "correct second control point Y");
                equal(round(controlPoints[1].x, COORD_PRECISION), cp2.x, "correct first control point X");
                equal(round(controlPoints[1].y, COORD_PRECISION), cp2.y, "correct first control point Y");
            });


        })();
        </script>

        <h1 id="qunit-header">CurveProcessor</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <div id="qunit-fixture">test markup, will be hidden</div>
        <ul id="log"></ul>

        <div id="container">
        </div>
    </body>