<!DOCTYPE html>
<html>
    <head>
        <title>kendo.chart</title>
        <script src="../../src/jquery.js"></script>
        <script src="../qunit.js"></script>
        <script src="../qunit-runner.js"></script>
        <link href="../qunit.css" type="text/css" rel="stylesheet"/>
    </head>
    <body>
        <script src="../../src/kendo.core.js"></script>
        <script src="../../src/kendo.chart.js"></script>
        <script src="util.js"></script>
        <script type="text/javascript">
            var Chart = kendo.ui.Chart,
                Box2D = Chart.Box2D,
                chartBox = new Box2D(0, 0, 800, 600),
                plotArea,
                lineChart,
                view;

            function setupLineChart(plotArea, options) {
                view = new ViewStub();

                lineChart = new Chart.LineChart(plotArea, options);
                lineChart.reflow();
            }

            (function() {
                var positiveSeries = { data: [1, 2], labels: {} },
                    negativeSeries = { data: [-1, -2], labels: {} },
                    VALUE_AXIS_MAX = 2,
                    CATEGORY_AXIS_Y = 2,
                    TOLERANCE = 0.1;

                function PlotAreaStub() { }

                $.extend(PlotAreaStub.prototype, {
                    axisX: {
                        getSlot: function(categoryIndex) {
                            return new Box2D(categoryIndex, CATEGORY_AXIS_Y,
                            categoryIndex + 1, CATEGORY_AXIS_Y);
                        }
                    },
                    axisY: {
                        getSlot: function(value) {
                            var value = typeof value === "undefined" ? 0 : value,
                                valueY = VALUE_AXIS_MAX - value,
                                slotTop = Math.min(CATEGORY_AXIS_Y, valueY),
                                slotBottom = Math.max(CATEGORY_AXIS_Y, valueY);

                            return new Box2D(0, slotTop, 0, slotBottom);
                        },
                        options: {}
                    }
                });

                // ------------------------------------------------------------
                module("Line Chart / Positive Values", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        setupLineChart(plotArea, { series: [ positiveSeries ] });
                    }
                });

                test("Creates points for lineChart data points", function() {
                    equal(lineChart._bars.length, positiveSeries.data.length);
                });

                test("Reports minimum series value", function() {
                    same(lineChart.valueRange().min, positiveSeries.data[0]);
                });

                test("Reports maximum series value", function() {
                    same(lineChart.valueRange().max, positiveSeries.data[1]);
                });

                test("Reports number of categories", function() {
                    setupLineChart(plotArea, {series: [ positiveSeries ]});
                    equal(lineChart.categoriesCount(), positiveSeries.data.length);
                });

                test("points are distributed across category axis", function() {
                    var pointsX = $.map(lineChart._bars, function(point) {
                        return point.box.x1;
                    });

                    same(pointsX, [0, 1]);
                });

                test("points are aligned to category axis", function() {
                    var pointsY = $.map(lineChart._bars, function(point) {
                        return point.box.y2;
                    });

                    same(pointsY, [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
                });

                test("points have set width", function() {
                    $.each(lineChart._bars, function() {
                        equal(this.box.width(), 1);
                    });
                });

                test("points have set height according to value", function() {
                    var pointHeights = $.map(lineChart._bars, function(point) {
                        return point.box.height();
                    });

                    same(pointHeights, [1, 2]);
                });

                // ------------------------------------------------------------
                module("Line Chart / Negative Values", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        setupLineChart(plotArea, { series: [ negativeSeries ] });
                    }
                });

                test("Reports minimum series value", function() {
                    same(lineChart.valueRange().min, negativeSeries.data[1]);
                });

                test("Reports maximum series value", function() {
                    same(lineChart.valueRange().max, negativeSeries.data[0]);
                });

                test("point tops are aligned to category axis", function() {
                    var pointsY = $.map(lineChart._bars, function(point) {
                        return point.box.y1;
                    });

                    same(pointsY, [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
                });

                test("points have set height according to value", function() {
                    var pointHeights = $.map(lineChart._bars, function(point) {
                        return point.box.height();
                    });

                    same(pointHeights, [1, 2]);
                });

                // ------------------------------------------------------------
                module("Line Chart / Mixed Values", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        setupLineChart(plotArea, { series: [ negativeSeries, positiveSeries ] });
                    }
                });

                test("Reports number of categories for two series", function() {
                    setupLineChart(plotArea, {series: [ positiveSeries, negativeSeries ]});
                    equal(lineChart.categoriesCount(), positiveSeries.data.length);
                });

                // ------------------------------------------------------------
                module("Line Chart / Mismatching series", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        setupLineChart(plotArea, {
                        series: [ { data: [1, 2, 3] },
                                  positiveSeries
                            ]
                        });
                    }
                });

                test("Reports minimum series value", function() {
                    same(lineChart.valueRange().min, 1);
                });

                test("Reports maximum series value", function() {
                    same(lineChart.valueRange().max, 3);
                });

                test("Reports number of categories", function() {
                    equal(lineChart.categoriesCount(), 3);
                });

                test("Missing values are represented as points with zero height", function() {
                    var pointHeights = $.map(lineChart._bars, function(point) {
                        return point.box.height();
                    });

                    same(pointHeights, [1, 1, 2, 2, 3, 0]);
                });

                test("points are aligned to category axis", 6, function() {
                    $.each(lineChart._bars, function() {
                        equal(this.box.y2, CATEGORY_AXIS_Y);
                    });
                });

                // ------------------------------------------------------------
                module("Line Chart / Stack / Positive Values", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        setupLineChart(plotArea, {
                            series: [ positiveSeries, positiveSeries ],
                            isStacked: true }
                        );
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(lineChart.valueRange().min, 2);
                });

                test("reports stacked maximum value", function() {
                    equal(lineChart.valueRange().max, 4);
                });

                test("points in first category are stacked", function() {
                    equal(lineChart._bars[1].box.y2, lineChart._bars[0].box.y1);
                });

                test("points have set height according to value", function() {
                    var pointHeights = $.map(lineChart._bars, function(point) {
                        return point.box.height();
                    });

                    same(pointHeights, [1, 1, 2, 2]);
                });

                // ------------------------------------------------------------
                module("Bar Chart / Stack / Negative Values", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        setupLineChart(plotArea, {
                            series: [ negativeSeries, negativeSeries ],
                            isStacked: true
                        });
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(lineChart.valueRange().min, -4);
                });

                test("reports stacked maximum value", function() {
                    equal(lineChart.valueRange().max, -2);
                });

                test("points in first category are stacked", function() {
                    equal(lineChart._bars[1].box.y1, lineChart._bars[0].box.y2);
                });

                test("stack tops are aligned to category axis", function() {
                    same([lineChart._bars[0].box.y1, lineChart._bars[2].box.y1],
                         [CATEGORY_AXIS_Y, CATEGORY_AXIS_Y]);
                });

                test("points have set height according to value", function() {
                    var pointHeights = $.map(lineChart._bars, function(point) {
                        return point.box.height();
                    });

                    same(pointHeights, [1, 1, 2, 2]);
                });

                // ------------------------------------------------------------
                module("Line Chart / Stack / Mixed Values", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        setupLineChart(plotArea, {
                            series: [{
                                data: [1, -1],
                                labels: {}
                            }],
                            isStacked: true
                        });
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(lineChart.valueRange().min, -1);
                });

                test("reports stacked maximum value", function() {
                    equal(lineChart.valueRange().max, 1);
                });

                test("points have set height according to value", function() {
                    var pointHeights = $.map(lineChart._bars, function(point) {
                        return point.box.height();
                    });

                    same(pointHeights, [1, 1]);
                });

                // ------------------------------------------------------------
                module("Line Chart / Stack / Mixed Series", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        setupLineChart(plotArea, {
                            series: [ positiveSeries, negativeSeries ],
                            isStacked: true
                        });
                    }
                });

                test("reports stacked minumum value", function() {
                    equal(lineChart.valueRange().min, -2);
                });

                test("reports stacked maximum value", function() {
                    equal(lineChart.valueRange().max, 2);
                });

                test("points have set height according to value", function() {
                    var pointHeights = $.map(lineChart._bars, function(point) {
                        return point.box.height();
                    });

                    same(pointHeights, [1, 1, 2, 2]);
                });
            })();

            (function() {
                var lineChart,
                    MARGIN = PADDING = BORDER = 5,
                    linePoint;

                function PlotAreaStub() { }

                $.extend(PlotAreaStub.prototype, {
                    axisX: {
                        getSlot: function(value) {
                            return new Box2D();
                        }
                    },
                    axisY: {
                        getSlot: function(categoryIndex) {
                            return new Box2D();
                        }
                    }
                });

                // ------------------------------------------------------------
                module("Line Chart / Configuration", {
                    setup: function() {
                        plotArea = new PlotAreaStub();
                        lineChart = new Chart.LineChart(plotArea, {
                            series: [{
                                data: [0, 1],
                                color: "#f00",
                                markers: {
                                    visible: false,
                                    size: 10,
                                    type: "triangle",
                                    border: {
                                        color: "marker-border",
                                        width: BORDER
                                    }
                                },
                                labels: {
                                    visible: false,
                                    font: "labels-font",
                                    color: "labels-color",
                                    background: "labels-background",
                                    border: {
                                        color: "labels-border",
                                        width: BORDER
                                    },
                                    margin: MARGIN,
                                    padding: PADDING
                                }
                            }]
                        });
                        linePoint = lineChart._bars[0];
                    }
                });

                test("applies visible to point markers", function() {
                    equal(linePoint.options.markers.visible, false);
                });

                test("applies series fill color to point markers", function() {
                    equal(linePoint.options.markers.background, "#f00");
                });

                test("applies size to point markers", function() {
                    equal(linePoint.options.markers.size, 10);
                });

                test("applies type to point markers", function() {
                    equal(linePoint.options.markers.type, "triangle");
                });

                test("applies border color to point markers", function() {
                    equal(linePoint.options.markers.border.color, "marker-border");
                });

                test("applies border width to point markers.", function() {
                    equal(linePoint.options.markers.border.width, BORDER);
                });

                test("applies visible to point labels", function() {
                    equal(linePoint.options.labels.visible, false);
                });

                test("applies color to point labels", function() {
                    equal(linePoint.options.labels.color, "labels-color");
                });

                test("applies background to point labels", function() {
                    equal(linePoint.options.labels.background, "labels-background");
                });

                test("applies border color to point labels", function() {
                    equal(linePoint.options.labels.border.color, "labels-border");
                });

                test("applies border width to point labels", function() {
                    equal(linePoint.options.labels.border.width, BORDER);
                });

                test("applies padding to point labels", function() {
                    equal(linePoint.options.labels.padding, PADDING);
                });

                test("applies margin to point labels", function() {
                    equal(linePoint.options.labels.margin, MARGIN);
                });

            })();

            (function() {
                var LinePoint = Chart.LinePoint,
                    point,
                    box,
                    marker,
                    label,
                    VALUE = 1;

                function createPoint(options) {
                    point = new LinePoint(VALUE, options);

                    box = new Box2D(0, 0, 100, 100);
                    point.reflow(box);

                    marker = point.children[0];
                    label = point.children[1];

                    view = new ViewStub();
                    point.getViewElements(view);
                }

                // ------------------------------------------------------------
                module("Line Point", {
                    setup: function() {
                        createPoint();
                    }
                });

                test("fills target box", function() {
                    sameBox(point.box, box);
                });

                test("creates marker", function() {
                    ok(marker instanceof Chart.BoxElement);
                });

                test("sets marker width", function() {
                    createPoint({ markers: { size: 10 } });
                    equals(marker.options.width, 10);
                });

                test("sets marker height", function() {
                    createPoint({ markers: { size: 10 } });
                    equals(marker.options.height, 10);
                });

                test("sets marker background color", function() {
                    same(marker.options.background, point.options.markers.background);
                });

                test("sets default marker border color based on background", function() {
                    createPoint({ markers: { background: "#cf0" } });
                    equals(marker.options.border.color, "#8fb300");
                });

                test("does not change marker border color if set", function() {
                    createPoint({ markers: { border: { color: "" } } });
                    equals(marker.options.border.color, "");
                });

                test("sets marker border width", function() {
                    createPoint({ markers: { border: { width: 4 } } });
                    equals(marker.options.border.width, 4);
                });

                test("sets marker visibility", function() {
                    createPoint({ markers: { visible: false }});
                    equals(marker.options.visible, false);
                });

                test("marker is positioned at top", function() {
                    createPoint({ isVertical: false, aboveAxis: true });
                    sameBox(marker.box, new Box2D(46, -4, 54, 4));
                });

                test("marker is positioned at bottom", function() {
                    createPoint({ isVertical: false, aboveAxis: false });
                    sameBox(marker.box, new Box2D(46, 96, 54, 104));
                });

                test("marker is positioned at right", function() {
                    createPoint({ isVertical: true, aboveAxis: true });
                    sameBox(marker.box, new Box2D(96, 46, 104, 54));
                });

                test("marker is positioned at left", function() {
                    createPoint({ isVertical: true, aboveAxis: false });
                    sameBox(marker.box, new Box2D(-4, 46, 4, 54));
                });

                // ------------------------------------------------------------
                module("Line Point / Labels", {
                    setup: function() {
                        createPoint();
                    }
                });

                test("sets label color", function() {
                    createPoint({ labels: { color: "#cf0" }});
                    same(label.options.color, "#cf0");
                });

                test("sets label background", function() {
                    createPoint({ labels: { background: "#cf0" }});
                    same(label.options.background, "#cf0");
                });

                test("sets label border color", function() {
                    createPoint({ labels: { border: { color: "#cf0" } }});
                    same(label.options.border.color, "#cf0");
                });

                test("sets label border width", function() {
                    createPoint({ labels: { border: { width: 4 } }});
                    same(label.options.border.width, 4);
                });

                test("sets label font", function() {
                    createPoint({ labels: { font: "label-font" }});
                    same(label.options.font, "label-font");
                });

                test("sets default left margin", function() {
                    same(label.options.margin.left, 5);
                });

                test("sets default right margin", function() {
                    same(label.options.margin.right, 5);
                });

                test("sets label visibility", function() {
                    createPoint({ labels: { visible: false }});
                    equals(label.options.visible, false);
                });

                test("label is positioned above marker", function() {
                    createPoint({ labels: { position: "above" } });
                    sameBox(label.box, new Box2D(41, -20, 59, -4));
                });

                test("label is positioned below marker", function() {
                    createPoint({ labels: { position: "below" } });
                    sameBox(marker.box, new Box2D(46, -4, 54, 4));
                });

                test("label is positioned right of marker", function() {
                    createPoint({ labels: { position: "right" } });
                    sameBox(marker.box, new Box2D(46, -4, 54, 4));
                });

                test("label is positioned left of marker", function() {
                    createPoint({ labels: { position: "left" } });
                    sameBox(marker.box, new Box2D(46, -4, 54, 4));
                });
            })();

        </script>

        <h1 id="qunit-header">kendo.chart</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <div id="qunit-fixture">test markup, will be hidden</div>
        <ul id="log"></ul>

    </body>
</html>
