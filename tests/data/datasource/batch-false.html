<!DOCTYPE html>
<html>
    <head>
        <title>Batch disabled</title>
        <script src="../../../src/jquery.js"></script>
        <script type="text/javascript" src="../../qunit.js"></script>
        <script type="text/javascript" src="../../qunit-runner.js"></script>
        <script type="text/javascript" src="../../jquery.mockjax.js"></script>
        <script src="../../../src/kendo.core.js"></script>
        <script src="../../../src/kendo.model.js"></script>
        <script src="../../../src/kendo.data.js"></script>
        <link rel="stylesheet" href="../../qunit.css" type="text/css" />
    </head>
    <body>
        <h1 id="qunit-header">QUnit example</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <script>
            var DataSource = kendo.data.DataSource,
                Model = kendo.data.Model.define(),
                dataSource;

            function setup(options) {
                var dataSource = new DataSource($.extend(true, {
                    schema: {
                        model: Model
                    },
                    transport: {
                        read: function(options) {
                            options.success([ {  id: 1, foo: "foo" } ]);
                        }
                    },
                }, options));

                dataSource.read();

                return dataSource;
            }

            module("batch disabled", {
                setup: function() {
                    dataSource = setup();                }
            });

            test("sync sends created destroyed and updated models", function() {
                var methods = [];

                dataSource._send = function(data, method) {
                    methods.push(method);
                    return [];
                }

                dataSource.sync();

                equal(methods.length, 3);
                equal(methods[0], "create");
                equal(methods[1], "update");
                equal(methods[2], "destroy");
            });

            test("sync sends updated model", function() {
                var model;
                var dataSource = setup({
                    transport: {
                        update: function(options) {
                            model = options.data;
                        }
                    }
                });

                dataSource.update(1, { foo: "bar" });
                dataSource.sync();

                ok(model.id, 1);
                ok(model.foo, "bar");
            });

            test("sync sends updated models in separate requests", function() {
                var models = [];
                var dataSource = setup({
                    transport: {
                        update: function(options) {
                            models.push(options.data);
                        }
                    }
                });

                dataSource.update(1, { foo: "bar" });
                dataSource.update(1, { foo: "baz" });
                dataSource.sync();

                ok(models.length, 2);
            });

            test("sync sends destroyed model", function() {
                var model;
                var dataSource = setup({
                    transport: {
                        destroy: function(options) {
                            model = options.data;
                        }
                    }
                });

                dataSource.destroy(1);
                dataSource.sync();

                ok(model.id, 1);
            });

            test("sync sends destroyed models in separate requests", function() {
                var models = [];
                var dataSource = setup({
                    transport: {
                        read: function(options) {
                            options.success([{id:1}, {id:2}]);
                        },
                        destroy: function(options) {
                            models.push(options.data);
                        }
                    }
                });

                dataSource.destroy(1);
                dataSource.destroy(2);
                dataSource.sync();

                ok(models.length, 2);
                ok(models[0].id, 1);
                ok(models[1].id, 2);
            });

            test("sync sends created model", function() {
                var model;
                var dataSource = setup({
                    transport: {
                        create: function(options) {
                            model = options.data;
                        }
                    }
                });

                dataSource.create({ foo: "bar"});
                dataSource.sync();

                ok(model.foo, "bar");
            });

            test("sync sends created models in separate requests", function() {
                var models = [];
                var dataSource = setup({
                    transport: {
                        read: function(options) {
                            options.success([{id:1}, {id:2}]);
                        },
                        create: function(options) {
                            models.push(options.data);
                        }
                    }
                });

                dataSource.create({ foo: "bar" });
                dataSource.create({ foo: "baz" });
                dataSource.sync();

                ok(models.length, 2);
            });

            test("sync updates models after completion when remote service returns updated data", function() {
                var dataSource = setup({
                    transport: {
                        update: function(options) {
                            options.success([{id: 1, foo: "bar"}]);
                        }
                    }
                });

                dataSource.update(1, { foo: "bar" });
                dataSource.sync();
                equal(dataSource.find(1).foo, "bar");
            });

            test("sync updates models after completion when remote service returns nothing", function() {
                var dataSource = setup({
                    transport: {
                        update: function(options) {
                            options.success();
                        }
                    }
                });

                dataSource.update(1, { foo: "bar" });
                dataSource.sync();
                equal(dataSource.find(1).foo, "bar");
            });

            test("sync updates models after multiple updates when service does not return changes", function() {

                var dataSource = setup({
                    transport: {
                        read: function(options) {
                            options.success([ { id: 1, foo: "foo"}, { id: 2, foo: "foo"} ]);
                        },
                        update: function(options) {
                            options.success();
                        }
                    }
                });

                dataSource.update(1, { foo: "bar" });
                dataSource.update(2, { foo: "bar" });
                dataSource.sync();
                equal(dataSource.find(1).foo, "bar");
                equal(dataSource.find(2).foo, "bar");
            });

            test("sync destroys models after completion when remote service returns nothing", function() {
                var dataSource = setup({
                    transport: {
                        destroy: function(options) {
                            options.success();
                        }
                    }
                });

                dataSource.destroy(1);
                dataSource.sync();
                equal(dataSource.find(1), undefined);
            });

            test("sync creates models after completion when remote service returns nothing", function() {
                var dataSource = setup({
                    transport: {
                        create: function(options) {
                            options.success();
                        }
                    }
                });

                dataSource.create({foo: "bar"});
                dataSource.sync();
            });

            test("sync sends updated models to remote transport", function() {
                var MyTransport = kendo.data.RemoteTransport.extend( {
                        read: function(options) {
                            options.success([{ id: 1, foo: "foo" }]);
                        }
                    });

                dataSource = setup({
                    transport: new MyTransport({
                        update: {
                            url: "foo"
                        }
                    })
                });

                $.mockjax({
                    url: "foo",
                    response: function() {
                        ok(true);
                        start();
                    }
                });

                dataSource.update(1, { foo: "bar" });
                dataSource.sync();
                stop(1000);
            });

            test("sync merges multiple results after update", function() {
                var data = [{id: 1, foo: "moo"}, {id: 2, foo: "boo"}],
                    modified = [
                        [{id: 1, foo: "foo"}, {id: 2, foo: "boo"}],
                        [{id: 1, foo: "foo"}, {id: 2, foo: "baz"}]
                    ],
                    dataSource = setup({
                        transport: {
                            read: function(options) {
                                options.success(data);
                            },
                            update: function(options) {
                                options.success(modified.shift());
                            }
                        }
                    });

                dataSource.read();
                dataSource.update(1, {id: 1, foo: "foo"});
                dataSource.update(2, {id: 2, foo: "baz"});
                dataSource.sync();

                var view = dataSource.view();
                equal(view[0].foo, "foo");
                equal(view[1].foo, "baz");
            });

            asyncTest("sync merge multiple results after update when response is out of order", function() {
                var data = [{id: 1, foo: "moo"}, {id: 2, foo: "boo"}],
                    called = false,
                    modified = [
                        [{id: 1, foo: "foo"}, {id: 2, foo: "boo"}],
                        [{id: 1, foo: "foo"}, {id: 2, foo: "baz"}]
                    ],
                    dataSource = setup({
                        transport: {
                            read: function(options) {
                                options.success(data);
                            },
                            update: function(data) {
                                setTimeout(function() { data.success(modified.shift());}, called ? 100 : 0);
                                called = true;
                            }
                        },
                        change: function() {
                            if (called) {
                                start();
                                var view = dataSource.view();
                                equal(view[0].foo, "foo");
                                equal(view[1].foo, "baz");
                            }
                        }
                    });

                dataSource.read();
                dataSource.update(1, {id: 1, foo: "foo"});
                dataSource.update(2, {id: 2, foo: "baz"});
                dataSource.sync();

                stop(500);
            });
        </script>
        <div id="qunit-fixture">test markup, will be hidden</div>
        <ul id="log"></ul>
    </body>
</html>
