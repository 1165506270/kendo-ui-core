<!DOCTYPE html>
<html>
    <head>
        <title>sync response</title>
        <script src="../../../src/jquery.js"></script>
        <script type="text/javascript" src="../../qunit/qunit/qunit.js"></script>
        <script type="text/javascript" src="../../qunit-runner.js"></script>
        <script type="text/javascript" src="../../jquery.mockjax.js"></script>
        <script src="../../../src/kendo.core.js"></script>
        <script src="../../../src/kendo.data.js"></script>
        <script src="../../../src/kendo.model.js"></script>
        <link rel="stylesheet" href="../../qunit/qunit/qunit.css" type="text/css" />
    </head>
    <body>
        <h1 id="qunit-header">QUnit example</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <script>
            var Model = kendo.data.Model, DataSource = kendo.data.DataSource, dataSource;

            function setup(options) {
                dataSource = new DataSource($.extend(true, {
                    data: [ { id: 1, foo: "foo" }, { id: 2, foo: "foo2" }  ],
                    schema: {
                        model: $.extend({}, Model, { id: "id" })
                    }
                }, options));

                dataSource.read();
            }

            function stubTransport(method, data) {
                var obj = {};
                data = data !== undefined ? data : [ { id: 1, foo: "bar" } ];
                obj[method] = function(options) {
                    options.success($.isFunction(data) ? data() : data);
                }

                stub(dataSource.transport, obj);
            }

            module("datasource sync response", {
                setup: setup
            });

            test("sync updates the fields of created model from array server response", function() {
                stubTransport("create");

                var model = new Model();
                dataSource.add(model);
                dataSource.sync();

                equal(model.id, 1);
                equal(model.get("foo"), "bar");
            });

            test("sync updates the fields of updated model from array server response", function() {
                stubTransport("update");

                var model = dataSource.get(1);
                model.set("foo", "bar");
                dataSource.sync();

                equal(model.get("foo"), "bar");
            });

            test("sync updates data from server response", function() {
                stubTransport("update");

                var model = dataSource.get(1);
                model.set("foo", "bar");
                dataSource.sync();

                equal(dataSource.data()[0].foo, "bar");
            });

            test("sync updates data if server response without content", function() {
                dataSource = new DataSource({
                    schema: {
                        model: {
                            id: "id"
                        },
                        data: "d.d"
                    },
                    transport: {
                        read: function(options) {
                            options.success({ d: { d: [{ id: 1, foo: "foo" }] } });
                        },
                        update: function(options) {
                            options.success(null);
                        }
                    }
                });

                dataSource.read();
                var model = dataSource.get(1);
                model.set("foo", "bar");
                dataSource.sync();

                equal(dataSource.data()[0].foo, "bar");
            });

            test("sync updates the fields of created model from single object server response", function() {
                stubTransport("create", { id: 1, foo: "foo" } );

                var model = new Model();
                dataSource.add(model);
                dataSource.sync();

                equal(model.id, 1);
                equal(model.get("foo"), "foo");
            });

            test("sync updates the fields of updated model from single object server response", function() {
                stubTransport("update", { id: 1, foo: "bar" } );

                var model = dataSource.get(1);
                model.set("foo", "bar");
                dataSource.sync();

                equal(model.id, 1);
                equal(model.get("foo"), "bar");
            });

            test("sync merges created model data with server response", function() {
                stubTransport("create", { id: 1 } );

                var model = new Model({ foo: "foo" });
                dataSource.add(model);
                dataSource.sync();

                equal(model.id, 1);
                equal(model.get("foo"), "foo");
            });

            test("sync merges updated model data with server response", function() {
                stubTransport("update", { id: 1 } );

                var model = dataSource.get(1);
                model.set("foo", "bar");
                dataSource.sync();

                equal(model.id, 1);
                equal(model.get("foo"), "bar");
            });

            test("sync updates created model when response is empty", function() {
                stubTransport("create", null );

                var model = dataSource.add({ foo: "foo" });
                dataSource.sync();

                equal(model.get("foo"), "foo");
                equal(model.dirty, false);
            });

            test("sync updates the state of updated model when response is empty", function() {
                stubTransport("update", null );

                var model = dataSource.get(1);
                model.set("foo", "bar");
                dataSource.sync();

                equal(model.get("foo"), "bar");
                equal(model.dirty, false);
                equal(dataSource._pristine[0].foo, "bar");
            });

            test("sync updates all created models with server response", function() {
                var response = [{id:1, foo: "foo"} , {id:2, foo: "bar"}];

                stubTransport("create", function() { return [response.shift()]; });

                var model1 = new Model();
                dataSource.add(model1);

                var model2 = new Model();
                dataSource.add(model2);
                dataSource.sync();

                equal(model1.id, 1);
                equal(model1.get("foo"), "foo");
                equal(model2.id, 2);
                equal(model2.get("foo"), "bar");
            });

            test("sync updates all updated models with server response", function() {
                var response = [{id:1, foo: "bar"} , {id:2, foo: "baz"}];

                stubTransport("update", function() { return [response.shift()]; });

                var model1 = dataSource.get(1);

                model1.set("foo", "bar" );

                var model2 = dataSource.get(2);

                model2.set("foo", "baz");

                dataSource.sync();

                equal(model1.get("foo"), "bar");
                equal(model2.get("foo"), "baz");
            });

            test("sync updates all created models with server response when batch is true and incomplete response", function() {
                setup({ batch: true });

                stubTransport("create", [{id:1, foo: "bar"} , {id:2, foo: "baz"}]);

                var model1 = new Model();
                dataSource.add(model1);

                var model2 = new Model();
                dataSource.add(model2);
                dataSource.sync();

                equal(model1.id, 1);
                equal(model1.get("foo"), "bar");
                equal(model2.isNew(), false);
                equal(model2.dirty, false);
            });

            test("sync updates all created models with server response when batch is true", function() {
                setup({ batch: true });

                stubTransport("create", [{ id:1, foo: "foo" }, { id:2 , foo: "bar" }]);

                var model1 = new Model();
                dataSource.add(model1);

                var model2 = new Model();
                dataSource.add(model2);
                dataSource.sync();

                equal(model1.id, 1);
                equal(model1.get("foo"), "foo");
                equal(model2.id, 2);
                equal(model2.get("foo"), "bar");
            });

            test("sync updates all updated models with server response when batch is true", function() {
                setup({ batch: true });

                stubTransport("update", [{ id:1, foo: "baz" }, { id:2 , foo: "bar" }]);

                var model1 = dataSource.get(1);

                model1.set("foo", "baz");

                var model2 = dataSource.get(2);

                model2.set("foo", "bar");
                dataSource.sync();

                equal(model1.get("foo"), "baz");
                equal(model2.get("foo"), "bar");
            });

            test("created models are no longer new after sync", function() {
                stubTransport("create");

                var model = new Model();
                dataSource.add(model);
                dataSource.sync();

                equal(model.isNew(), false);
            });

            test("created model has no changes after sync", function() {
                stubTransport("create");

                var model = new Model();
                dataSource.add(model);
                dataSource.sync();

                equal(model.dirty, false);
            });

            test("updated model has no changes after sync", function() {
                stubTransport("update");

                var model1 = dataSource.get(1);

                model1.set("foo", "foo");

                dataSource.sync();

                equal(model1.dirty, false);
            });

            test("sync clears destroyed models", function() {
                stubTransport("destroy");
                var model = dataSource.get(1);

                dataSource.remove(model);
                dataSource.sync();

                dataSource.sync();

                equal(dataSource.transport.calls("destroy"), 1);
            });

            test("sync uses the parse method of the reader", function() {
                var reader = stub(dataSource.reader, {
                    parse: function() {
                        return [{id:1}];
                    },
                    data: function(result) {
                        return result;
                    }
                });

                stubTransport("create");

                var model = new Model();
                dataSource.add(model);
                dataSource.sync();

                equal(reader.calls("parse"), 1);
                equal(model.id, 1);
            });

            test("sync uses the data method of the reader", function() {
                var reader = stub(dataSource.reader, {
                    parse: function(result) {
                        return [{id:1}];
                    },
                    data: function(result) {
                        return [{id:1}];
                    }
                });

                stubTransport("create");

                var model = new Model();
                dataSource.add(model);
                dataSource.sync();

                equal(reader.calls("parse"), 1);
                equal(model.id, 1);
            });

            test("sync raises change event after delete", 1, function() {
                stubTransport("destroy");

                dataSource.remove(dataSource.get(1));

                dataSource.bind("change", function() {
                    ok(true);
                });

                dataSource.sync();
            });

            test("sync raises change event after create", 1, function() {
                stubTransport("create");

                var model = new Model();
                dataSource.add(model);

                dataSource.bind("change", function() {
                    ok(true);
                });

                dataSource.sync();
            });

            test("sync raises change event after update", 1, function() {
                stubTransport("update", [{ foo: "moo" }]);

                dataSource.get(1).set("foo", "moo");

                dataSource.bind("change", function() {
                    ok(true);
                });

                dataSource.sync();
            });

            test("get returns new models after sync", function() {
                stubTransport("create", [{ id: 3, foo: "moo" }]);

                dataSource.add({});
                dataSource.sync();

                equal(dataSource.get(3).get("id"), 3);
            });

            test("cancelChanges does not remove the added models after sync", function() {
                stubTransport("create", [{ id: 3, foo: "moo" }]);

                dataSource.add({});
                dataSource.sync();

                dataSource.cancelChanges();

                ok(dataSource.get(3));
            });

            test("cancelChanges does not remove the added models after sync", function() {
                stubTransport("create", [{ id: 3, foo: "moo" }]);

                dataSource.add({});
                dataSource.sync();

                dataSource.cancelChanges();

                ok(dataSource.get(3));
            });

            test("cancelChanges does not revert the updated models after sync when Model has fields defined", function() {
                setup({
                    schema: {
                        model: {
                            fields: {
                                foo: "foo"
                            }
                        }
                    }
                });

                stubTransport("create", [{ id: 42, foo: "moo" }]);

                dataSource.add();

                dataSource.sync();

                dataSource.cancelChanges();

                equal(dataSource.get(42).foo, "moo");
            });

            test("cancelChanges does not revert the deleted models after sync", function() {
                stubTransport("destroy", [{ id: 2, foo: "moo" }]);

                dataSource.remove(dataSource.get(2));
                dataSource.sync();

                dataSource.cancelChanges();

                ok(!dataSource.get(2));
            });

        </script>
        <div id="qunit-fixture">test markup, will be hidden</div>
        <ul id="log"></ul>
    </body>
</html>
