<!DOCTYPE html>
<html>
    <script src="../../../src/jquery.js"></script>
    <script type="text/javascript" src="../../qunit.js"></script>
    <script type="text/javascript" src="../../qunit-runner.js"></script>
    <script type="text/javascript" src="../../jquery.mockjax.js"></script>
    <script src="../../../src/kendo.core.js"></script>
    <script src="../../../src/kendo.query.js"></script>
    <script src="../../../src/kendo.model.js"></script>
    <script src="../../../src/kendo.datasource.js"></script>
    <link rel="stylesheet" href="../../qunit.css" type="text/css" />

    <body>
        <h1 id="qunit-header">QUnit example</h1>
        <h2 id="qunit-banner"></h2>
        <div id="qunit-testrunner-toolbar"></div>
        <h2 id="qunit-userAgent"></h2>
        <ol id="qunit-tests"></ol>
        <script>
            var DataSource = kendo.data.DataSource,
                Model = kendo.data.Model;

            function setup(transport, data, options) {
                options = $.extend(true, {
                    schema: {
                        model: kendo.data.Model.define()
                    },
                    transport: $.extend({
                        read: function(options) {
                           options.success(data || [{ id: 1, foo: "foo" }]);
                        },
                    }, transport)
                }, options);
                var dataSource = new DataSource(options);

                dataSource.read();

                return dataSource;
            }

            test("sync calls the update method of the transport for the updated records", function() {
                var updated;
                var dataSource = setup({
                    update: function(options) {
                        updated = options.data;
                    }
                });

                dataSource.update(1, { foo: "bar" });
                dataSource.sync();

                equal(updated.length, 1);
                equal(updated[0].foo, "bar");
            });

            test("sync does not call update method if there are no updated records", function() {
                var updated;
                var dataSource = setup({
                    update: function(options) {
                        updated = options.data;
                    }
                });

                dataSource.sync();

                ok(updated === undefined);
            });

            test("sync calls the create method of the transport for the created records", function() {
                var created;
                var dataSource = setup({
                    create: function(options) {
                        created = options.data;
                    }
                });

                dataSource.create({ foo: "bar" });
                dataSource.create({ foo: "baz" });
                dataSource.sync();

                equal(created.length, 2);
                equal(created[0].foo, "bar");
                equal(created[1].foo, "baz");
            });

            test("sync does not call create method if there are no created records", function() {
                var created;
                var dataSource = setup({
                    create: function(options) {
                        created = options.data;
                    }
                });

                dataSource.sync();

                ok(created === undefined);
            });

            test("sync calls the destroy method of the transport for the destroyed records", function() {
                var destroyed;
                var dataSource = setup({
                    destroy: function(options) {
                        destroyed = options.data;
                    }
                });

                dataSource.destroy(1);
                dataSource.sync();

                equal(destroyed.length, 1);
                equal(destroyed[0].foo, "foo");
            });

            test("sync does not call destroy method if there are no destroyed records", function() {
                var destroyed;
                var dataSource = setup({
                    destroy: function(options) {
                       destroyed = options.data;
                    }
                });

                dataSource.sync();

                ok(destroyed === undefined);
            });

            test("sync with sendAllFields=true passes entire record to update", function() {
                var updated,
                    dataSource = setup({
                        update: function(options) {
                            updated = options.data;
                        }
                    },
                    [{ id: 1, foo: "foo", bar: "bar" }],
                    { sendAllFields: true });

                dataSource.update(1, { foo: "bar" });
                dataSource.sync();

                equal(updated[0].foo, "bar");
                equal(updated[0].bar, "bar");
            });

            test("sync with sendAllFields=false passes only changes to update", function() {
                var updated,
                    dataSource = setup({
                        update: function(options) {
                            updated = options.data;
                        }
                    },
                    [{ id: 1, foo: "foo", bar: "bar" }],
                    { sendAllFields: false });

                dataSource.update(1, { foo: "bar" });
                dataSource.sync();

                equal(updated[0].foo, "bar");
                equal(updated[0].bar, undefined);
            });

             test("sync with sendAllFields=true passes entire record to destroy", function() {
                var destroyed,
                    dataSource = setup({
                        destroy: function(options) {
                            destroyed = options.data;
                        }
                    },
                    [{ id: 1, foo: "foo", bar: "bar" }],
                    { sendAllFields: true });

                dataSource.destroy(1);
                dataSource.sync();

                equal(destroyed[0].foo, "foo");
                equal(destroyed[0].bar, "bar");
            });

            test("sync with sendAllFields=false passes only the id of the record to destroy", function() {
                var destroyed,
                    dataSource = setup({
                        destroy: function(options) {
                            destroyed = options.data;
                        }
                    },
                    [{ id: 1, foo: "foo", bar: "bar" }],
                    { sendAllFields: false });

                dataSource.destroy(1);
                dataSource.sync();

                equal(destroyed[0].id, 1);
                equal(destroyed[0].foo, undefined);
                equal(destroyed[0].bar, undefined);
            });

            test("sync with batch=false calls transport update for every record", function() {
                var updated = [],
                    dataSource = setup({
                        update: function(options) {
                            updated.push(options.data);
                        }
                    },
                    [{ id: 1, foo: "foo"}, { id: 2, foo: "bar"}],
                    { batch: false });

                dataSource.update(1, { foo: "bar" });
                dataSource.update(2, { foo: "baz" });
                dataSource.sync();

                equal(updated.length, 2);
                equal(updated[0].foo, "bar");
                equal(updated[1].foo, "baz");
            });

            test("sync with batch=false calls transport create for every new record", function() {
               var created = [],
                    dataSource = setup({
                        create: function(options) {
                            created.push(options.data);
                        }
                    },
                    undefined,
                    { batch: false });

                dataSource.create({ foo: "bar" });
                dataSource.sync();

                equal(created.length, 1);
                equal(created[0].foo, "bar");
            });

            test("sync with batch=false calls transport destroy for destroyed record", function() {
               var destroyed = [],
                    dataSource = setup({
                        destroy: function(options) {
                            destroyed.push(options.data);
                        }
                    },
                    [{ id: 1, foo: "foo", bar: "bar" }],
                    { batch: false });

                dataSource.destroy(1);
                dataSource.sync();

                equal(destroyed.length, 1);
                equal(destroyed[0].foo, "foo");
            });

            test("sync with batch.mode=single calls transport update with created/updated/destroyed records", function() {
               var data,
                    dataSource = setup({
                        update: function(options) {
                            data = options.data;
                        }
                    },
                    [{ id: 1, foo: "foo" }, { id: 2, foo: "baz" }],
                    {
                        batch: { mode: "single" }
                    });

                dataSource.destroy(1);
                dataSource.create({ foo: "bar" });
                dataSource.update(2, { foo: "foo" });
                dataSource.sync();

                equal(data.updated[0].id, 2);
                equal(data.updated[0].foo, "foo");
                equal(data.destroyed[0].id, 1);
                equal(data.created[0].foo, "bar");
            });

            test("sync change the state of created model when successful", function() {
                var dataSource = new DataSource({
                    transport: {
                        create: {
                            url: "foo",
                            dataType: "json",
                            type: "POST",
                            contentType: "text/json"
                        }
                    },
                    batch: false,
                    schema: {
                        model: Model.define(),
                        status: function() {
                            return true;
                        }
                    }
                });

                $.mockjax({
                    contentType: "text/json",
                    url: "foo",
                    responseText: '[{"id": 1, "foo": "bar"}]',
                    response: function() {
                        ok(true);
                        start();
                    }
                });
                stop(1000);

                dataSource.create({ foo: "bar" });
                dataSource.bind("change", function() {
                    var createdModels = dataSource._createdModels();
                    equal(createdModels.length, 0);
                });
                dataSource.sync();
            });

            test("sync change the state for the successful created record to Model.PRISTINE", function() {
                var dataSource = new DataSource({
                    transport: {
                        create: {
                            url: "foo",
                            dataType: "json",
                            type: "POST",
                            contentType: "text/json"
                        }
                    },
                    batch: false,
                    schema: {
                        model: Model.define(),
                        status: function() {
                            return true;
                        }
                    }
                });

                $.mockjax({
                    contentType: "text/json",
                    url: "foo",
                    responseText: '[{"id": 1, "foo": "bar"}]',
                    response: function() {
                        ok(true);
                        start();
                    }
                });
                stop(1000);

                dataSource.create({ foo: "bar" });
                dataSource.bind("change", function() {
                    var model = this.model(1);
                    equal(model.id(), 1);
                    equal(model.get("foo"), "bar");
                    equal(model.state, Model.PRISTINE);
                });
                dataSource.sync();
            });

            test("sync triggers error if error callback", function() {
                var data = [{id: 1, foo: "foo"}],
                    errorWasCalled = false;
                var dataSource = setup({
                    update: function() {
                        dataSource._syncError(data);
                    }},
                    data
                );
                dataSource.update(1, { foo: "bar" });
                dataSource.bind("error", function() {
                   errorWasCalled = true;
                });
                dataSource.sync();

                ok(errorWasCalled);
            });

            test("sync reject the changes if success status is false", function() {
                var data = [{id: 1, foo: "foo"}],
                    errorWasCalled = false;
                var dataSource = setup({
                    update: function() {
                        dataSource._syncSuccess(data, {status:false, data: arguments[0].data});
                    }},
                    data
                );
                dataSource.update(1, { foo: "bar" });
                dataSource.bind("error", function() {
                   errorWasCalled = true;
                   equal(this.model(1).state, Model.UPDATED);
                });
                dataSource.sync();
                ok(errorWasCalled);
            });

            test("sync change the state for the successful updated record to Model.PRISTINE", function() {
                var data = {data: [{id: 1, foo: "foo"}]};
                var dataSource = setup({
                    update: function() {
                        dataSource._syncSuccess(data.data ,{status: true, data: arguments[0].data});
                    }},
                    data,
                    {
                        schema:{
                            data: function(data) {
                                return data.data;
                            }
                        }
                    }
                );

                dataSource.update(1, { foo: "bar" });
                dataSource.bind("change", function() {
                    var model = this.model(1);
                    equal(model.id(), 1);
                    equal(model.get("foo"), "bar");
                    equal(model.state, Model.PRISTINE);
                    equal(dataSource._updatedModels().length, 0);
                });
                dataSource.sync();
            });

            test("sync remove destroyed models and remove its data", function() {
                var data = [{id: 1, foo: "foo"}];
                var dataSource = setup({
                    destroy: function() {
                        dataSource._syncSuccess(data, []);
                    }},
                    $.map(data, function(i) { return i; }),
                    {
                        schema:{
                            status: function() {
                                return true;
                            }
                        }
                    }
                );

                dataSource.destroy(1);
                dataSource.bind("change", function() {
                    equal(this._data.length, 0);
                    equal(this._models[1], undefined);
                    equal(this._map[1], undefined);
                });
                dataSource.sync();
            });

            test("sync merge the results if read before sync complete", function() {
                var dataSource = new DataSource({
                    transport: {
                        read: function(options) {
                            options.success([{id: 1, foo: "foo"}, {id: 2, foo: "bar"}]);
                        }
                    },
                    schema: {
                        model: Model.define()
                    }
                });
                dataSource.read();

                dataSource.create({foo: "baz"});
                dataSource.update(1, {foo: "bar"});
                dataSource.destroy(2);
                dataSource.read();

                var created = dataSource._createdModels();
                var updated = dataSource._updatedModels();
                var destroyed = dataSource._destroyedModels();
                var view = dataSource.view();

                equal(created.length, 1);
                equal(created[0].foo, "baz");
                equal(destroyed.length, 1);
                equal(destroyed[0].foo, "bar");
                equal(destroyed[0].id, 2);
                equal(updated.length, 0);

                equal(view.length, 2);
                equal(view[0].id, 1);
                equal(view[0].foo, "foo");
                equal(view[1].id, 2);
                equal(view[1].foo, "bar");
            });
        </script>
        <div id="qunit-fixture">test markup, will be hidden</div>
        <ul id="log"></ul>
    </body>
</html>
