<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>kendo.ui.Editor Tests</title>

<script src="../../src/jquery.js"></script>
<script src="../qunit/qunit/qunit.js"></script>
<script src="../qunit-runner.js"></script>
<script src="../../src/kendo.core.js"></script>
<script src="../../src/kendo.fx.js"></script>
<script src="../../src/kendo.data.js"></script>
<script src="../../src/kendo.popup.js"></script>
<script src="../../src/kendo.list.js"></script>
<script src="../../src/kendo.combobox.js"></script>
<script src="../../src/kendo.dropdownlist.js"></script>
<script src="../../src/kendo.window.js"></script>
<script src="../../src/kendo.colorpicker.js"></script>
        <script src="../../src/kendo.editor.js"></script>
<script src="util.js"></script>

<link rel="stylesheet" href="../qunit/qunit/qunit.css" />
<link rel="stylesheet" href="../../styles/web/kendo.common.css" />

<style> html { font-size: 12px; } </style>
</head>
<body>

<div><textarea cols="20" rows="4" id="Editor1" name="Editor1"></textarea></div>

<script>

var SystemHandler;

$("#Editor1").kendoEditor();

module("Editor / SystemHandler", {
    setup: function() {
        SystemHandler = kendo.ui.editor.SystemHandler;
        editor = getEditor();
        editor.focus();
    }
});

test('keydown calls endTyping if typing in progress', function() {
        var force = false;
        editor.keyboard = {
        isModifierKey: function() { return true},
        endTyping: function () { force = arguments[0]; },
        startTyping: function () {},
        isTypingInProgress: function() { return true}
    };
    var handler = new SystemHandler(editor);
    handler.keydown();

    ok(force);
});

test('keydown does not call endTyping if not modifier key', function() {
    var called = false;
    editor.keyboard = {
        isModifierKey: function () { return false },
        isSystem:function() { return false},
        endTyping: function () { called = true },
        startTyping: function () { },
        isTypingInProgress: function () { return true }
    };

    var handler = new SystemHandler(editor);
    handler.keydown();

    ok(!called);
});

test('keydown does not call endTyping if typing not in progress', function() {
    var called = false;
    editor.keyboard = {
        isModifierKey: function() { return true},
        endTyping: function () { called = true; },
        startTyping: function () { },
        isTypingInProgress: function () { return true }
    };

    var handler = new SystemHandler(editor);
    handler.keydown();

    ok(called);
});


test('keydown if modifier key creates start restore point', function() {
    editor.keyboard = {
        isModifierKey: function() { return true},
        isTypingInProgress: function () { return false }
    };

    var handler = new SystemHandler(editor);
    handler.keydown();

    ok(undefined !== handler.startRestorePoint);
});

test('keydown returns true if modifier key', function() {
    editor.keyboard = {
        isModifierKey: function () { return true },
        isTypingInProgress: function () { return false }
    };

    var handler = new SystemHandler(editor);
    ok(handler.keydown())
});

test('keydown if system command and changed creates end restore point', function() {
    editor.keyboard = {
        isModifierKey: function () { return true },
        isTypingInProgress: function () { return false },
        isSystem:function(){ return true}
    };

    var handler = new SystemHandler(editor);
    handler.changed = function() {
        return true;
    }

    handler.keydown();
    editor.keyboard.isModifierKey = function() { return false};
    handler.keydown();

    ok(undefined !== handler.endRestorePoint);
});

test('keydown if system command and changed sets start restore point to end restore point', function() {
    editor.keyboard = {
        isModifierKey: function () { return true },
        isTypingInProgress: function () { return false },
        isSystem: function () { return true }
    };

    var handler = new SystemHandler(editor);
    handler.changed = function () {
        return true;
    }

    handler.keydown();
    editor.keyboard.isModifierKey = function () { return false };
    handler.keydown();

    equal(handler.startRestorePoint, handler.endRestorePoint);
});
test('keydown returns true if system command and changed', function() {
    editor.keyboard = {
        isModifierKey: function () { return true },
        isTypingInProgress: function () { return false },
        isSystem: function () { return true }
    };

    var handler = new SystemHandler(editor);
    handler.changed = function () {
        return true;
    }
    handler.keydown();
    editor.keyboard.isModifierKey = function() { return false};
    ok(handler.keydown());
});

test('keydown creates undo command if system command and changed', function() {
    editor.keyboard = {
        isModifierKey: function () { return true },
        isTypingInProgress: function () { return false },
        isSystem: function () { return true }
    };

    var handler = new SystemHandler(editor);
    handler.changed = function () {
        return false;
    }
    var command;

    editor.undoRedoStack.push = function() {
        command = arguments[0];
    }
    handler.keydown()
    editor.keyboard.isModifierKey = function() { return false};
    handler.changed = function () {
        return true;
    }
    handler.keydown()

    ok(undefined !== command);
});

test('changed returns false if editor contents remain the same', function() {
    editor.keyboard = {
        isModifierKey: function() { return true},
        isTypingInProgress: function () { return false }
    };

    var handler = new SystemHandler(editor);
    handler.keydown();

    ok(!handler.changed());
});

test('changed returns false if editor contents changed', function() {
    editor.keyboard = {
        isModifierKey: function () { return true },
        isTypingInProgress: function () { return false }
    };

    var handler = new SystemHandler(editor);
    handler.keydown();
    editor.body.innerHTML = 'foo';
    ok(handler.changed());
});


test('keyup creates undo command if system command and changed', function() {
    editor.keyboard = {
        isModifierKey: function () { return true },
        isTypingInProgress: function () { return false },
        isSystem: function () { return true }
    };

    var handler = new SystemHandler(editor);
    handler.changed = function () {
        return false;
    }
    var command;

    editor.undoRedoStack.push = function() {
        command = arguments[0];
    }

    handler.keydown()
    editor.keyboard.isModifierKey = function() { return false};
    handler.keydown()
    handler.changed = function () {
        return true;
    }

    handler.keyup()

    ok(undefined !== command);
});


test('keyup does not create undo command if system command and changed', function() {
    editor.keyboard = {
        isModifierKey: function () { return true },
        isTypingInProgress: function () { return false },
        isSystem: function () { return true }
    };

    var handler = new SystemHandler(editor);
    handler.changed = function () {
        return true;
    }
    var command;

    editor.undoRedoStack.push = function() {
        command = arguments[0];
    }

    handler.keyup()

    ok(undefined === command);
});

</script>

<h1 id="qunit-header">kendo.ui.Editor Tests</h1>
<h2 id="qunit-banner"></h2>
<div id="qunit-testrunner-toolbar"></div>
<h2 id="qunit-userAgent"></h2>
<ol id="qunit-tests"></ol>
<div id="qunit-fixture">test markup, will be hidden</div>
<ul id="log"></ul>

</body>
</html>
