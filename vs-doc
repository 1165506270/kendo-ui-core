#!/usr/bin/env node

var fs = require("fs");
var template = require("build/kendo-template").template;

var classes = [];

var vsDocTemplate = fs.readFileSync("kendo.all-vsdoc.js.tpl").toString();

processFilesRecursive("docs", /.+md/, function(fileName) {
    var contents = fs.readFileSync(fileName).toString();

    var root = {
        title: "Root",
        contents: "",
        children: []
    };

    var node = root, level = 0;

    contents.split("\n").forEach(function(line) {
        match = line.match(/^(#+) (.+)$/);
        if (match) {
            var currentLevel = match[1].length;
            var currentTitle = match[2];

            var newNode = {
                title: currentTitle,
                contents: "",
                children: []
            };


            if (currentLevel > level + 1) {
                while (level < currentLevel - 1) {
                    var filler = { title: "-Dummy-", contents: "", children: [], parent: node };
                    node.children.push(filler);
                    node  = filler;
                    // console.log("++");
                    level ++;
                }
            } else {
                while (level >= currentLevel) {
                    node = node.parent;
                    level --;
                    // console.log("--");
                }
            }

            level = currentLevel;

            newNode.parent = node;
            // console.log("new node", newNode.title, "level" , currentLevel, "parent", node.title);
            node.children.push(newNode);
            node = newNode;
        } else {
            node.contents += line + "\n";
        }
    });

    var theClass = {
        name: root.children[0].title,
        methods: []
    }

    root.children[0].children[2].children.forEach(function(child) {
        var match = child.title.match(/\w+/);

        var method = {
            name: match[0],
            description: child.contents,
            parameters: []
        };

        child.children.forEach(function(member) {
            if (/Parameters/.test(member.title)) {
                member.children.forEach(function(param) {
                    var match = param.title.match(/(\w+).+`(.*)`/);
                    method.parameters.push({
                            name: match[1],
                            type: match[2],
                            description: param.contents
                        })
                });
            }
            else if (/Returns/.test(member.title)) {
                match = member.contents.match(/`(\w+)`(.*)/);
                method.returns = match[1];
                method.returnsDescription = match[2];
            }
        });

        theClass.methods.push(method);

    });

    classes.push(theClass);
});

classes = classes.sort(function(a, b) {
    if (a.name < b.name) {
        return -1;
    } else {
        return 1;
    }
});

var theTemplate = template(vsDocTemplate);

console.log(theTemplate(classes));

function processFilesRecursive(dir, filterRegex, callback) {
    var files = fs.readdirSync(dir),
        fileName,
        stat;

    for (var i = 0; i < files.length; i++) {
        fileName = dir + "/" + files[i];
        stat = fs.statSync(fileName);

        if (!stat.isFile()) {
            processFilesRecursive(fileName, filterRegex, callback);
        } else if (filterRegex.test(fileName)) {
            callback(fileName);
        }
    }
}

// vim: ft=javascript
